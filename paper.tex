\documentclass[12pt,a4paper]{article}
\usepackage{ccicons}
\usepackage{hyperref}
\usepackage{minted}

\setminted{autogobble=true, tabsize=2, linenos=true, frame=single, breaklines=true}

\newcommand{\version}{v0.2 Draft}

\begin{document}
\begin{centering}

	\Large{Workshop Paper}
	\par
	\Huge{Debugging of Modern RxJS-based Frontend Web Applications}
	\par
	\vspace{2ex}

	\normalsize{
		Manuel Alabor\\
		Supervised by Prof. Dr. Markus Stolze\\
		\par
		\vspace{2ex}
		HSR University of Applied Sciences Rapperswil\\
		\par
		\vspace{2ex}
		\today{} (\version)
	}
	\par
	\vspace{2ex}

	\begin{quotation}
		\small{
			\noindent\textbf{Abstract}---\input{./abstract.tex}
		}
		\par
		\vspace{4ex}
	\end{quotation}
\end{centering}

\section{Introduction}

The debugger is an essential tool to get a deeper understanding of the runtime behavior of a software system. Software engineers use it to understand why particular circumstances lead to an unexpected failure during execution or to step through unknown program code in order to get themselves accustomed with it.

IDEs as well as the developer tools of modern web browsers provide battle-tested debugger utilities \footnote{\url{https://developer.mozilla.org/en-US/docs/Tools/Debugger}} to inspect frontend application code at runtime. With an imperative programming model in mind, they let the user jump from program statement to statement, stop execution upon hitting a breakpoint while having a closer look at the values currently assigned to variables. By the time they are even able to preserve call stacks for asynchronously executed code which was a hassle before \footnote{\url{https://developers.google.com/web/tools/chrome-devtools/javascript/reference\#call-stack}}.

Modern web frontend applications use the browser for rendering sophisticated, reactive user interfaces. Reactive applications contrast more traditional computer programs: Where i.e. the conversion from one image format to another is a one-off process with clearly defined start and end point, a reactive application handles a continuos flow of stimuli: While moving the cursor over UI elements, the application provides steady feedback to the user on the display.

Todays state of the art debugger tools can be used to work with reactive applications as well. (Conditional) breakpoints are essential to interrupt the code execution at the right moment to inspect the inner workings of the reactive program. As we will see later though, software engineers tend to fall back to a log-based debugging approach when the complexity of a system increases.

% Previous research \cite{10.1145/3180155.3180156} \cite{10.1145/2884781.2884815} in the field of debugging for reactive applications as well as our own experience, particular with RxJS\footnote{\url{https://rxjs.dev/}}-based web applications, show that another review on this area may yield new insights.

Within this paper, we will answer the following two research questions:

\begin{itemize}
	\item \emph{RQ1: What challenges do frontend engineers face when debugging RxJS based code?}
	\item \emph{RQ2: How can the experience of frontend engineers during debugging of RxJS-based code be improved?}
\end{itemize}

Transcripts of informal interviews and ``war stories'' collected from multiple practitioners will give us insight in the challenges they face in their day-to-day jobs. We will evaluate and validate three cases extracted from their statements in order to answer \emph{RQ1}.

Later, we propose for \emph{RQ2} three solution concepts to resolve previously identified problems which ultimately should improve the debugging experience for RxJS-based code.

The implementation and validation of these proposals is then part of a third research question \emph{RQ3} and will be part of a future iteration on the topic and not part of this paper:

\begin{itemize}
	\item \emph{RQ3: What is the impact of a proposed solution on the debugging experience of a frontend engineer?}
\end{itemize}

We will conclude this introductory section with the clarification of important terms. Section~\ref{sec:interviews} presents the interview results along with the collected war stories and formalizes two recurrent challenges. With Section~\ref{sec:discussion}, we will have a look at current and previous research regarding debugging of reactive applications as well as specific tooling. We are going to validate presented challenges against currently available tools within Section~\ref{sec:study}, show threats to validity of our work in Section~\ref{sec:threats} and finally end with an outlook on future iterations.

\subsection{Reactive Applications}

Salvaneschi et al. \cite{comprehendingReactiveApplications} define the Reactive Application \emph{(RA)} as a computer program which processes a continuos, indefinite and ever-changing flow of information. It is contrasted by a traditional application which consumes and processes one piece of input while producing a one-off output result: Think of an image format conversion program which takes an HEIF\footnote{\url{https://nokiatech.github.io/heif/technical.html}} image file for input, processes it and outputs an JPEG file likewise.

\begin{figure}[h]
	\centering
	\emph{TODO}

	\caption{Traditional vs. Reactive Application}
	\label{fig:reactive-application}
\end{figure}

Further, Salvaneschi et al. provide a set of examples of what a RA might achieve using a three-parted classification schema: A \emph{synthetic application} transforms and processes streams of information. hence multiple image conversions one after another or in parallel could be implemented as a synthetic, RA. Beside the modelling of pure data flows, RAs are prevalent in the area of user interfaces \emph{(UI)}: They can be identified as \emph{interactive applications} and \emph{graphical animations} here.

Various ways of implementing RAs emerged over time. The Observer design pattern \cite{observerDesignPattern}, originated in Object Oriented Programming \emph{(OOP)}, is a basic pattern we can find in many of todays API implementations \cite{ownPaper}. Functional Programming \emph{(FP)} shines with specific reactive language extensions like Fran (Haskell) \cite{SurveyOnReactiveProgramming} or more recently REScala (Scala) \cite{10.1145/2577080.2577083}. The declarativeness of FP finally lead to what we understand under ``Reactive Programming'' today.

\subsection{Reactive Programming}

Reactive programming \emph{(RP)} is a declarative programming paradigm. Where engineers use imperative programing languages to tell a program every step \emph{how} to do something, a declarative language allows to describe \emph{what} wants to be achieved. The languages runtime system then figures out a way to satisfy that given description. RP specifically allows the description of a dependency graph of values and transformations over time.

\begin{figure}[h]
	\centering
	\emph{TODO}

	\caption{Reactive Programming Graph}
	\label{fig:reactive-programming}
\end{figure}

An RP environment provides (i) language constructs to describe mentioned graphs, often in form of a domain specific language \emph{(DSL)} \cite{REScala} \cite{otherRPDSL}. At program runtime, a (ii) runtime system takes care that changed values are propagated through the graph, transformations are recomputed where necessary and a consistent state is maintained.

\subsection{Debugging Concepts}

We divide debugging concepts roughly into three categories: Traditional \textbf{imperative-focused debuggers} provide basic functionality to interact with programs at runtime: Once code execution is paused (i.e. using a breakpoint at a given statement), we gain access to the current call stack and the values assigned to variables of a given frame. Manual control of the programs execution allows to inspect the programs behavior step by step as well as assigning new values to variables ``on-the-fly''.

Where individual transformations of an RP based program can be inspected using traditional debuggers, they fall short in understanding the greater model of the dependency graph. In fact, RP provides its own challenges to debuggers: So are call stacks spoiled with invocations of RP runtime system internal matter or breakpoints can only be used on the imperative parts of transformations rather than on the data flow within the graph. Various \textbf{reactive debuggers} and visualization tools for specific RP runtimes emerged over the past few years \cite{REDebuggerSalvaneschi} \cite{RxViz} \cite{RxFiddle} exploring this field. They have knowledge of the dependency graph and therefore allow improved interaction with RP concepts.

In matters of time, traditional as well as reactive debuggers work with the present state of the programs execution only. They lack knowledge about what happened before or what is going to happen in the future. This shortcoming is tedious, especially when debugging a problem depending from multiple complex circumstances in a system. An \textbf{omniscient debugger} \cite{omniscientDebuggerPaper} \cite{mozillaRR} does not interact with the executed program directly. Instead, it records runtime telemetry and provides an interface for later inspection. Engineers can ``time travel'' back and fore through the program execution trace without the hassle of reconstructing a given failure situation over and over again. This concept comes with its own set of challenges, i.e. demands on storage capacity or efficient user experience \emph{(UX)} design. \cite{omniscientDebuggerProblems}

\subsection{ReactiveX and RxJS}

Reactive Extensions is an open source project providing an API description for RP concepts. It describes itself as ``\dots a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming'' \cite{reactivex}.  The API specification introduces the concept of the  \mintinline{TypeScript}{Observable} at its core. An \mintinline{TypeScript}{Observable} has the ability to be composed with other \mintinline{TypeScript}{Observable}s and eventually describe the dependency graph known in RP. A multitude of operators allow the transformation of values and \mintinline{TypeScript}{Observable}s within the graph.

The ReactiveX community works on a variety of reference implementations\footnote{\url{http://reactivex.io/languages.html}}: Libraries for Java, C\#, JavaScript and many more allow to work with similar API semantics on different software architecture levels.

RxJS is the reference implementation for JavaScript. Its current major version 6 is completely done in TypeScript\footnote{\url{https://www.typescriptlang.org/}} and provides the core elements of the ReactiveX API specification. Large projects like Angular embed and use RxJS\cite{angualrrxjs}. The Listing \ref{lst:rp-with-rxjs} shows a short example of RP using RxJS.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		// Add Example
		const x: string = 'Hello World';
	\end{minted}
	\caption{Reactive Programming with RxJS}
	\label{lst:rp-with-rxjs}
\end{listing}

\section{Interviews and War Stories}
\label{sec:interviews}

\subsection{Informal Interviews}

In order to prepare to give an answer on the first research question, we started with a series of informal interviews. We talked to professionals about their experiestack defined through our research area since we were interested in as many different perspective on the topic as possible in this early stage. Eventually, we interviewed five engince in working with RP in their daily jobs. We did not limit the selection of our interview partners by the tech neers: Four work or worked more recently with Angular\footnote{\url{todo}} and ngrx\footnote{\url{todo}} to develop frontend applications. Two of them stated to have more explicit experience with RxJS further. The fifth subject works currently with a combination of akka\footnote{\url{todo}} and akka-streams\footnote{\url{todo}} in Scala to create backend applications. The agenda available in Appendix~\ref{sec:interviewquestions} was used to maintain focus during the interview sessions.

We identified several recurring topics throughout all the interviews. All of the subjects noted that they think of RP as an invaluable tool to describe and model dependencies between multiple data sources. Most of them appreciate how RP allows them to implement data transformations in a concise and composable way. The complexity of concurrent programming can be hidden well behind a simple DSL one subject noted further.

For the implementation, all subjects noted that a language with a strong type system is to be preferred: The compiler gives the guarantee of basic code correctness which is why e.g. TypeScript is used by all the subjects working with RxJS and Angular.

None of the subjects remembered debugging RP code to be a positive experience, independent of the technology used. All of the subjects use traditional debugging tools. Redux DevTools \footnote{\url{todo}} is in use by all four subjects working with ngrx. There was mention of any more specific debugging tool in regards of akka and akka-streams.

One particular subject with more in-depth knowledge on RxJS described situations where they would have wished for tools which could ``understand'' the actual \mintinline{TypeScript}{Observable} graph better: (i) When an error is thrown within the function passed to an operator, the generated stack trace reflects where the operator called the function rather than the actual location where the function is implemented. (ii) In order to understand how data traverses through the graph, subjects augmented code manually with the \mintinline{TypeScript}{tap}\footnote{\url{todo}} operator to log values. A less invasive way would be preferable as stated.

\subsection{War Stories}

Based on the results of the interviews, we compiled a request for more specific factual reports. We asked professional software engineers about their most recent debugging experience in regards of RxJS, either good or bad. We were able to gather responses from one RxJS core team member, two Google Developer Experts and two engineers building web and mobile applications for a fintech company eventually.

We could verify previously gathered interview data with the results from the new reports: The subjects tend to manually add log statements to their code in order to understand its behavior, especially when things get more complex. Three subjects even claimed using specialized logging functionalities provided through rxjs-spy\footnote{url{todo}}. This library allows to ``tag'' specific points in the \mintinline{TypeScript}{Observable} graph with a probe. In addition to report values traversing the graph, each probe notifies about events when an observer subscribes or unsubscribes to them or when the source \mintinline{TypeScript}{Observable} completes \cite{rxjs-lifecycle} \cite{rxjs-spy-events}. As the subjects stated, the knowledge about these additional events helps in situations where they need to find problems within a graph composing multiple asynchronous data sources on multiple levels. Without it, they were blind to what actually happens within the system.

In addition to more sophisticated logging, three subjects reported that they built a habit of decomposing complex graphs into smaller, simpler bits and running those in a dedicated environment like Rx Visualizer\footnote{\url{https://rxviz.com/}} or StackBlitz\footnote{\url{https://stackblitz.com/}}.

\subsection{Summary}

The interpretation of the combined interview and war stories data gives us an idea about two main challenges software engineers have to overcome during debugging activities of RxJS-based code:

It is crucial to the engineers to \textbf{understand data flows}  within the \mintinline{TypeScript}{Observable} graph. Questions like ``Which source emitted a value at what time?'' or ``What is the result of a specific transformation?'' are common in this context. Once a program fails, software engineers need to \textbf{rely on traditional debugger tools}. Though providing help to some extent, the tools lack of specific knowledge about the RP runtime environment adds some oddities to the debugging process: The (i) functionalities allowing step-wise navigation through the code does not respect the RP context. Assume we have set a breakpoint at \mintinline{TypeScript}{i * 2} on line~2 of Listing~\ref{lst:rxjs-step-controls}. Once the debugger hits the breakpoint and we instruct it to ``Step Over'', the debugger will lead us to the internal implementation of the \mintinline{TypeScript}{map} operator instead to line~3. (ii) Stack traces include information about the invocation of internal functions which, most of the time, do not provide any valuable information to the engineers further.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		timer().pipe(
		  map(i => i * 2),
		  map(i => i - 1)
		).subscribe();
	\end{minted}
	\caption{Example RxJS Stream With Breakpoint on Line 2 Within the Arrow Function}
	\label{lst:rxjs-step-controls}
\end{listing}


\section{Discussion of Previous Efforts}
\label{sec:discussion}

Our work is not the first approach on understanding and improving on the struggles software engineers face when working on RP code, no matter of using RxJS or not. We are going to present academic as well as non-academic efforts which contributed in the field of RP debugging in the past.

\subsection{Reactive Inspector}

Salvaneschi et al. did focus their research heavily on RP during the mid 2010s. Beside the creation of REScala in 2014 \cite{REScala}, an RP DSL and runtime for the Scala programming language, they looked into the debugging habits of software engineers as well. In the paper ``Debugging for Reactive Programming'' \cite{positiveEffectsRP}, Salvaneschi et al. elaborate on the necessity of RP debugging tools which can understand the specific language abstractions. With the plugin \emph{Reactive Inspector} \footnote{\url{http://guidosalva.github.io/reactive-inspector/}} for the Eclipse IDE, they provide a debugger which understands the RP language abstractions of REScala. One of its main features is the visualization of the internal dependency graph. The new class of  breakpoints, the ``reactive breakpoints'', builds upon the visualized graph as well: They do not depend on a specific line of code or statement rather then on a specific node in the graph. The execution of the program can be interrupted e.g. once a node retains a specific output value or an event of interest takes place in the runtime. Along with the RP specific debugging features, \emph{Reactive Inspector} implements omniscient debugging concepts as well: Time travel allows to record and replay runtime behavior at a later time without reexecution.

\subsection{rxfiddle}

\emph{rxfiddle} proposed by Banken et al. is the first reference implementation of their RP debugger architecture for the ReactiveX API specification described in their paper ``Debugging Data Flows in Reactive Programs'' \cite{rxfiddle}. The design defines two independent parts: The (i) \emph{Host instrumentation} instruments a ReactiveX implementation to emit events at runtime (e.g. when an \mintinline{TypeScript}{Observable} is created or subscribed) which get collected. The (ii) \emph{Visualizer} component interprets these events and presents them along two dimensions: The StoryFlow graph \cite{storyflow} shows when an \mintinline{TypeScript}{Observable} is created and how it interacts with other \mintinline{TypeScript}{Observable}s. An additional marble diagram\footnote{Marble diagrams are used in the ReactiveX community to describe the behavior of an \mintinline{TypeScript}{Observable} over its life time. They are considered valuable for documentation \cite{marblediagrams} as well as for testing \cite{marbletesting}} for every \mintinline{TypeScript}{Observable} is used to display the values it emits over time.

The reference implementation supports event collection for RxJS-based code in version 4 and 5. It can either be used on a local development machine on existing projects or by copying code snippets to the online available.


rxspy-js

\begin{itemize}
	\item Closer look to past Research
	\item \dots and the tools which were built based on it
	\item Set up war story extract to be replicated with existing tooling
\end{itemize}

\begin{itemize}
	\item Brief overview on specific tooling
	\item For frontend, but also other tiers
	\item Rxviz \footnote{\url{https://rxviz.com/}} see also \url{https://rxviz.com/feedback} for input?
	\item rxjs-spy \footnote{\url{https://github.com/cartant/rxjs-spy}}
	\item rxfiddle \cite{10.1145/3180155.3180156}
	\item reactive-inspector \cite{10.1145/2884781.2884815}
	\item TOD \cite{5287015}
\end{itemize}


\section{Study Design}
\label{sec:study}

\begin{itemize}
	\item Use prev section to build experiments using existing tooling
	\item Validate stories and interviews
\end{itemize}

\section{Future Work}
\label{sec:future}

\begin{itemize}
	\item Pick up results from war stories and experiment
	\item Propose one solution per challenges
	\item Sketch how this could look like
	\item This answers RQ2
\end{itemize}

\section{Threats to Validity}
\label{sec:threats}

\begin{itemize}
	\item Informal interviews/war stories only
	\begin{itemize}
		\item Describe background of interview partners
		\item Only 4 Participants in experiment
		\item Code in experiment carefully crafted... Though is it representative?
		\
	\end{itemize}
\end{itemize}

\section{Conclusion}
\label{sec:conclusion}

\begin{itemize}
	\item Recap Past Developments in RP Debugging
	\item Recap proposed solution
	\item Whats next in PA2?
	\item Whats the vision for the thesis?
\end{itemize}


\section{Appendix}

\subsection{Interview Questions}
\label{sec:interviewquestions}

\begin{itemize}
	\item When did you last apply RP?
	\item What technology did you use RP with?
	\item What was the best experience you had with RP?
	\item \dots and what was the worst? \dots Can you elaborate on the concrete situation?
\end{itemize}

\bibliographystyle{splncs04}
\bibliography{bibliography.bib}

\section*{License}
\ccby\thinspace\thinspace This work is licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.
\end{document}