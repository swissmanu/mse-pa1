\documentclass[sigplan,screen,review]{acmart}
\usepackage{ccicons}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{./tikzit}

\setminted{autogobble=true, tabsize=2, linenos=true, frame=single, breaklines=true}

% Top Matter: https://mirror.kumi.systems/ctan/macros/latex/contrib/acmart/acmart.pdf
\acmConference[SPLASH '20]{SPLASH '20: 7th Workshop on Reactive and Event-based Languages \& Systems}{November 15--20, 2020}{Chicago}
\title{Debugging of RxJS-based Applications}
\author{Manuel Alabor}
\affiliation{
	\institution{HSR University of Applied Sciences}
	\city{Rapperswil}
	\country{Switzerland}
}
\email{malabor@hsr.ch}




\begin{document}

\begin{abstract}
	\input{./abstract.tex}
\end{abstract}

\begin{CCSXML}
	<ccs2012>
	   <concept>
		   <concept_id>10011007</concept_id>
		   <concept_desc>Software and its engineering</concept_desc>
		   <concept_significance>500</concept_significance>
		   </concept>
	 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering}

\keywords{reactive programming, debugging, empirical software engineering}

\maketitle

\section{Introduction}

The (graphical) user interface (\emph{UI} or \emph{GUI}) of an application handles two constant flows of data: External user input (e.g. mouse, touch or keyboard interaction) is interpreted and forwarded to the system. Once the system processed an interaction and updated its internal state accordingly, it notifies the UI about these changes which are relayed to the user.

\begin{figure}
	\centering
	\tikzfig{ui-data-flow}
	\Description{Schematic visualization of a basic UI application. The user interacts with the UI. The UI component interprets and forwards interactions to the system. The system sends update notifactions to the UI eventually.}
	\caption{Basic dataflows in a UI Application.}
	\label{fig:ui-data-flows}
\end{figure}

To implement the dataflows as shown in Figure~\ref{fig:ui-data-flows} to drive a UI, the Observer design pattern\cite{gamma1995design} is often used and variations of the pattern are omnipresent today.

The Observer design pattern has its roots in the Object Oriented Programming paradigm (\emph{OOP}), hence relies on imperative code constructs to form a dataflow. Reactive Programming (\emph{RP}) is another approach to realize such flows: It inherits the declarative way of implementing functionality from Functional Programming (\emph{FP}), i.e. dataflows are rather described than implemented step by step\cite{10.1145/2501654.2501666}. RP functionality is usually available in the form of a library providing necessary abstractions, either for imperative or declarative programming languages.

According to the IEEE Standard Glossary of Software Engineering, \emph{debug} is an activity ``to detect, locate, and correct faults in a computer program.''\cite{ieeeglossary} From interpreting memory dumps, manually adding log statements to trace program execution up to the point where specialized debugging programs can interrupt a running process and interact with it on a low level, debugging utilities took different forms over time.

Modern IDEs and internet browsers ship with their own set of debugging tools. These traditional debuggers are specialized in working with imperative, controlflow oriented program code. E.g., when an engineer wants to know which part of the program called a particular function, the call stack gives a clear answer to this question. Assuming a dataflow oriented program implemented using RP, the question, what transformation function processed a piece of information right before another cannot be answered using a call stack anymore: The stack leads to the internals of the RP runtime environment rather than to the transformations logical predecessor.

These exemplary questions demonstrate the limits of a traditional controlflow oriented debugger which is not able to interpret RP abstractions, and as a result, cannot give the correct answer to a dataflow specific inquiry. Regardless of previous research efforts \cite{10.1145/2577080.2577083} \cite{10.1145/2884781.2884815} \cite{10.1145/3180155.3180156} in the field of RP debugging, we will show in this paper that engineers struggle nonetheless in applying effective techniques and utilities. For doing so, we interviewed several software engineers and collected ``war stories'' about the challenges they face in their day-to-day jobs when applying RP. Based on this collected evidence, we will validate their statements in an observational study using RxJS and search for an answer to our first research question:

\begin{itemize}
	\item \emph{RQ1: What challenges do software engineers face when debugging RxJS-based code?}
\end{itemize}

In response to this, we are going to present concepts on how to resolve previously identified challenges and answer the second research question:

\begin{itemize}
	\item \emph{RQ2: How can the experience of software engineers during debugging of RxJS-based code be improved?}
\end{itemize}

The implementation and validation of these proposals lead to our third and last research question, whose answer will be part of a future iteration on the topic:

\begin{itemize}
	\item \emph{RQ3: What is the impact of proposed solutions on the debugging experience of software engineers?}
\end{itemize}

We will conclude this introductory section with the clarification of important terms. Section~\ref{sec:interviews} continues with insights on the conducted interviews and the collected war story reports. We present our observational study intended to validate former insights in Section~\ref{sec:study} and have a look at previous research efforts regarding the debugging of RP code in Section~\ref{sec:discussion}. Finally, we will answer RQ2 in Section~\ref{sec:future} ``Future Work''.

\subsection{Reactive Programming}

RP is a declarative programming paradigm originated in FP. Where engineers use imperative programming languages to specify every step \emph{how} a program has to do something, declarative languages allow to describe \emph{what} the program should achieve ultimately. A runtime system then figures out a way to satisfy that description and executes it. RP functionality is usually provided in form of a language extension for a specific programming language (e.g. REScala for Scala\cite{10.1145/2577080.2577083}) or as a library (e.g. RxJS for JavaScript\cite{rxjs})

Either way, both usually provide a (i) domain specific language (\emph{DSL}) to describe dataflow graphs, how they depend on each other and how data flowing through should be transformed. At program execution, a (ii) runtime environment evaluates these descriptions and creates a representation of the specified graphs. It then takes care that values are processed and propagated correctly through them as well as that a consistent system state\cite{10.1145/2501654.2501666} is always maintained.

\subsection{Debugging Process Model}

Layman et al. \cite{Layman_Diep_Nagappan_Singer_Deline_Venolia_2013} use the debugging process model, an iterative, hypothesis refinement process, to formalize the general activity of debugging a computer program in their paper.

\begin{figure}[H]
	\centering
	\tikzfig{debugging-process-model}
	\Description{Debugging Process Model after Layman et al. \cite{Layman_Diep_Nagappan_Singer_Deline_Venolia_2013}}
	\caption{Debugging Process Model after Layman et al. \cite{Layman_Diep_Nagappan_Singer_Deline_Venolia_2013}}
	\label{fig:debugging-process-model}
\end{figure}

The process consists of three steps and includes a feedback loop: After the engineer (i) gathered sufficient context information (e.g. ways to reproduce the failure or details about external factors) and understands the situation satisfactory, they generate a hypothesis on the origins of the bug or what impact a change made to the program might have. With the intent to proof their hypothesis, the engineer then (ii) instruments the defective program using suitable tools (e.g. adding log statements, setting breakpoints or removing code parts). Finally, the instrumented system gets (iii) challenged against the formed hypothesis. E.g., code statements are executed step by step using a debugger or trace logs are analyzed and compared against expected behavior. If the hypothesis turns out to be correct, the debugging process stops. If not, the newly gained knowledge about the problem is used to build a refined hypothesis and start a new iteration.

\subsection{Debugger Concepts}

Software engineers have many tools and utilities at hand which help them to interact with and gain insight on the behavior of a defective program. Tools range from the instrumentation of source code with trace log statements (manually or automated) to specialized utilities allowing them to directly interact with a program at runtime.

Many of these specialized utilities differentiate themselves fundamentally in regards of the concepts they are built upon. We identified and will use the following three categories to structure them:

Traditional (i) \emph{imperative-focused debuggers} provide functionality to interact with programs at runtime: Once a breakpoint pauses the program execution, they provide access to the current call stack and the values assigned to variables of a given stack frame. Manual control of the program execution allows inspecting its behavior step by step as well as assigning new values to variables ``on-the-fly.''

RP provides its own set of challenges to debuggers: Call stacks expose internal invocations of the RP runtime system rather than e.g., the predecessor transformation according to the dataflow graph. Further, breakpoints can only be used on the imperative parts of transformations and lack the functionality of interrupting execution when the RP runtime hits a specific node within the graph. A (ii) \emph{reactive debugger} can interpret the underlying graph model of a RP runtime system. It leverages on it and provides specialized tools e.g., to navigate, visualize or instrument the dataflow graph \cite{10.1145/2884781.2884815} \cite{10.1145/3180155.3180156} \cite{rxviz}.

Traditional, as well as reactive debuggers work with the \emph{current} state of a programs execution only. They lack information about what happened before or what is going to happen in the future. This shortcoming is tedious, especially when debugging a problem depending on many complex circumstances in a system. An (iii) \emph{omniscient debugger} \cite{5287015} \cite{DBLP:journals/corr/OCallahanJFHNP17} does not interact with the executed program directly. Instead, it records runtime telemetry and provides an interface for later inspection. Engineers can ``time travel'' back and forth through the program execution trace without the hassle of reconstructing a given failure situation over and over again.

\subsection{ReactiveX and RxJS}

``Reactive Extensions'' (\emph{ReactiveX}) is an open-source project. Its members and contributors created a generic description of a RP API. They further provide reference implementations of this API along with RP language extensions for various programming languages like Java, C\#, or JavaScript\footnote{\url{http://reactivex.io/languages.html}}. ReactiveX summarizes the API as ``\dots a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming''\cite{reactivex}. The core concept of the API specification is the Observable\footnote{There is no known relation between ReactiveX' concept of the Observable and the deprecated Java class \href{https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Observable.html}{\mintinline{TypeScript}{java.util.Observable}}.}: An Observable can be composed and linked (``piped'') with other Observables. It can push (``emit'') values to its dependents. Multiple depending Observables form and describe a dataflow graph eventually. A multitude of operators allows the transformation of values and (higher-order\footnote{An Observable emitted by another Observable is considered a Higher-Order Observable. This naming is related to the concept of higher-order functions in mathematics and computer science.}) Observables. Values emitted from an Observable can be subscribed, which is closely related to the Observer design patterns \mintinline{Java}{attach} method.

RxJS\cite{rxjs} is the reference implementation of the ReactiveX API specification for JavaScript. Its current major version 6 is implemented using TypeScript and is used by large projects like Angular\cite{angualrrxjs}. Listing \ref{lst:rp-with-rxjs} shows an example of RP using RxJS in TypeScript.

\begin{listing}
	\begin{minted}{TypeScript}
		import { of } from 'rxjs';
		import { filter, map } from 'rxjs/operators';

		of(0, 1, 2, 3, 4).pipe(  // Create Observable
			filter(i => i < 4),	  // Omit integers >= 4
			map(i => i * 2)        // Multiply int. by 2
		).subscribe(console.log) // Logs: 0, 2, 4, 6
	\end{minted}
	\Description{Basic RxJS example creating an Observable emitting four integers. Each integer is processed by two operators and finally written to the console.}
	\caption{Basic RxJS example creating an Observable emitting four integers. Each integer is processed by two operators and finally written to the console.}
	\label{lst:rp-with-rxjs}
\end{listing}


The RxJS community uses \emph{marble diagrams} as shown in Figure~\ref{fig:marble-diagram} to document \cite{marblediagrams} the runtime behavior of an Observable visually. Unit test libraries\cite{marbletesting} use this abstraction to encode the behavior of mocked Observables or to describe assertions.

\begin{figure}
	\centering
	\tikzfig{marble-diagram}
	\Description{A Marble Diagram visualizing the Observable in Listing~\ref{lst:rp-with-rxjs}. From left to right, each marble represents an emitted value of 0, 2, 4, and 6. The vertical line at the last marble indicates that the Observable completed after emitting value \mintinline{TypeScript}{6}.}
	\caption{A Marble Diagram visualizing the Observable in Listing~\ref{lst:rp-with-rxjs}. From left to right, each marble represents an emitted value. The vertical line at the last marble indicates that the Observable completed after emitting \mintinline{TypeScript}{6}.}
	\label{fig:marble-diagram}
\end{figure}


\section{Interviews and War Stories}
\label{sec:interviews}

On the way of finding our interview partners and war stories reporters, we noticed it to be a challenge on its own to find people who understand themselves as users of RP and related technologies. E.g., even though Angular makes heavy use of RxJS, we will see that many engineers do not directly interact with its abstractions when building ``basic'' UIs. In the end, we were able to gather compelling statements which we are going to present in this section.

\subsection{Interviews}

We organized informal interviews which allowed us to gain insight in how software engineers work with RP in their daily jobs. We talked to five engineers (following identified using the codes \emph{I1} through \emph{I5}) and asked them about the technologies they use, what their personal experience with RP was, what they most liked and most disliked about it. All interviews were conducted remotely using video chat.

Our first three interview partners I1 to I3 declared to currently work or more recently have worked with RxJS in conjunction with Angular and/or ngrx\footnote{\url{https://ngrx.io/}} to develop frontend web applications. By being the creator of a visualizer for RxJS Observables, I4 was a proficient RxJS user. Our fifth interview partner I5 was a backend engineer who used akka-streams\footnote{\url{https://akka.io/}} in Scala to model dataflows for a WebSocket-based\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API}}, reactive API layer serving a web frontend application.

All of the interviewees referred to RP with an overall positive experience. We heard statements similar to ``RP is a good way for composing multiple data sources'' (I1) and ``having a statically typed language combined with RP already guarantees some kind of basic correctness of my program'' (I5) repeatedly throughout all sessions. Hence a significant strength of RP seems to be the ability to describe complex dataflow constructs using a specialized DSL. The learning curve can be steep for a novice engineer though: ``Being challenged with new abstractions [of Angular and ngrx] already, I experienced RxJS concepts and operators to be hard to convey'' stated I3, giving lectures in frontend web application development.

It was interesting to hear that, especially in the area of developing web applications using Angular, our partners seemed not to have to work with pure RxJS code often. E.g., when using ngrx for state management, ``The framework hides Observables from its main API surface carefully so you do not have to interact with them directly'' (I2). As soon as our interviewees had to extend built-in functionalities with their own features, e.g., a new effect\footnote{\url{https://ngrx.io/guide/effects}}, I1 and I2 valued the possibility to interact with underlying Observables though.

When asked explicitly about what they dislike the most about RP, all interview partners, with no exception, emphasized the debugging process of an RP program as unsatisfactory. The fact that our interviewees remembered the search for a bug as something negative did not surprise, hence a bug is commonly something negative afflicted. It was remarkable though that statements like ``In 99\% of all cases, I add console.log statements manually and run the program over and over again, trying to understand what is happening'' (I1) were prevalent and showed \emph{why} our partners dislike RP debugging in particular. I1 to I3 mentioned the Redux DevTools\footnote{\url{https://chrome.google.com/webstore/detail/redux-devtools}} as particular helpful when debugging Angular/ngrx applications nonetheless. Further, I1 noted marble diagrams as valuable in order to understand how an RxJS Observable works, whether during development or debugging.

\subsection{War Stories}

After we built a first intuition for how software engineers work with RP by evaluating the interviews, we were interested in more RxJS-specific, hands-on experiences. We asked the engineering community via Twitter\footnote{\url{https://twitter.com/swissmanu/status/1242429409208029185}} about their personal, most recent RxJS debugging war story and sent out various emails with the same request. After reaching out, we were able to collect five responses: One by an RxJS core team member (R1), two from Angular Google Developer Experts (R2/3) and another set of reports by two software engineers (R4/5) building web and mobile applications using React and RxJS, which includes the author of this paper.

In their report, R3 focused on how they built code with improved testability because of recent changes in RxJS: ``[\dots] in the beginning, it was very hard to write asynchronous tests [\dots]. I really disliked [\dots] you were forced to pass a TestScheduler''. Allowing to pass the scheduler explicitly as parameter forced them to introduce code, which was only necessary for testing reasons they stated further. With its current major version, RxJS 6 improved heavily on the  \mintinline{TypeScript}{TestScheduler}. The runtime environment itself can be augmented with the scheduler now, which results in cleaner code.

Even though the share of non-productive, testing-related code necessary to build mature RxJS-based applications was mentioned to have decreased today, R2 as well as R4 and R5 commented on the common practice of manually modifying production code during debugging sessions, hence confirming earlier statements from our interview partners. R5 described a specific scenario where they suspected a problem within a complex Observable composition: Having multiple asynchronous, remote data sources, they used Observables to model the dependencies between them and implemented computations on their results as operators. On top, each data source could re-emit updated versions of previously requested information at any time. After a week in production, though tested thoroughly, the first of many bugs got reported: ``Displayed numbers kept changing where we did not expected them to. In other places, they were not rerendered where they were supposed to after, e.g. after we changed them in the system,'' they told us. The browsers debugger tools and its breakpoints did not help much since the operators were executed several times. Other parts of the stream were impossible to grasp, even with conditional breakpoints. ``I started to inspect the flow [\dots] with console.logs and later also using tags from rxjs-spy which exposed more detailed life cycle information.'' After a time-consuming log analysis, they finally were able to resolve all bugs. The log statements added were removed in the aftermath, though the rxjs-spy related code was left in the Observable stream in case they might be needed again in the future. (We will elaborate on the functionality of rxjs-spy in Section~\ref{sec:discussion}.)

In a related war story, R2 discloses similar invasive practices using an external tool when they implemented logic to request and cache batches of a remote resource: ``It took quite some time to get it right and one of the most invaluable tools proved to be Stackblitz\footnote{Stackblitz is a full JavaScript development environment available online \url{https://stackblitz.com/}} which gave us ability to quickly create smaller working examples and iterate on them.'' This sandboxed setting allowed them to run, debug, and iterate on selected pieces of a larger Observable stream. Even though the final result had to be integrated back into the actual application, the extra effort was worth the result the engineer concluded in their report.

A final story describes yet another way of utilizing an external tool: Rather than using a dedicated sandbox to develop pieces of a more complex system, R5 used Rx Visualizer, an online visualization utilities to generate marble diagrams from real code. Like in the report before, it was necessary to extract parts from the codebase of the actual application. But once done, the visualizations helped a lot in order to understand when values were emitted, when subscriptions changed and when Observables completed: ``Marble diagrams were a huge help in order to understand detailed runtime and life cycle behaviors of the Observable.''

\subsection{Insights}

The sentiment in both the interviews and the reported war stories in regards to RP with RxJS was positive. The software engineers value how they can describe dataflows using a DSL, even though the learning curve was perceived as steep. We heard some interesting reports on how RxJS is applied in a daily development environment: Marble diagrams help to understand  an Observables behavior and are useful to implement tests. Large frameworks like Angular hide some of the complexity of RxJS but allow engineers to make use of its full power once the pre-provided functionality needs to be extended.

Most participants considered a statically typed language like TypeScript, a fundamental necessity allowing them to implement dataflow graphs with minimal, formal correctness, as we heard in the interviews. When the engineers needed to interact with dataflow graphs at runtime, e.g. to debug the behavior of a specific part of a stream, we noticed throughout most reports that they were not 100\% satisfied with the feature set they were provided with through traditional debugging tools. The lack of knowledge about RP abstractions like transformation operators or life cycles was reported as irritating. Almost all of the reporters referred to the practice of modifying their source code manually and adding log statements where they assumed a problem to overcome the feature gaps in traditional debuggers. Listing~\ref{lst:rxjs-debugging} exemplifies two challenges when debugging a stream of Observables with imperative-focused debugging tools.

\begin{listing}
	\begin{minted}{TypeScript}
		interval(1000).pipe(
		  map(i => i * 2),
		  take(4),
		  tap(console.log)
		).subscribe(showValue); // Emits: 0, 2, 4, 6
	\end{minted}
	\caption{An Observable emitting a sequence of increasing integers every second. Traditional breakpoints are possible inside the arrow function on Line~2. Though a breakpoint can be added on Line~3, it will never be hit during the actual execution of the \mintinline{TypeScript}{take} operator. Line~4 shows a manually introduced trace log statement using the \mintinline{TypeScript}{tap} side effect operator.}
	\label{lst:rxjs-debugging}
\end{listing}

Where a breakpoint can easily be added to Line~2 within the arrow function, this is impossible for \mintinline{TypeScript}{take} on Line~3. One would need to place the breakpoint within the operators' internal implementation instead which can be cumbersome in case the operator is used in a different stream as well. Once the breakpoint on Line~2 interrupts the execution of the program, we will notice another shortcoming related to this circumstance: Rather than representing the logical flow implemented using the DSL, the call stack as shown in Listing~\ref{lst:rxjs-call-stack} points deep into RxJS' internal implementation. That is why a traditional debuggers step controls cannot operate on the dataflow graph; It just can not interpret this level of abstraction.

\begin{listing}
	\begin{minted}{TypeScript}
		<anonymous> RxJS
			rxjs 6.5.2/internal/operators/map.js:49
			rxjs 6.5.2/internal/Subscriber.js:66
			rxjs 6.5.2/internal/observable/interval.js:23
			rxjs 6.5.2/internal/scheduler/AsyncAction.js:71
			// ...
	\end{minted}
	\caption{A call stack showing the internal RxJS execution stack for a breakpoint in the arrow function on Line~2 in Listing~\ref{lst:rxjs-debugging}.}
	\label{lst:rxjs-call-stack}
\end{listing}

We learned that simple trace augmentation, like on Line~4 in Listing~\ref{lst:rxjs-debugging}, logs emitted values only. This might be helpful when debugging simple graph compositions, though it lacks lifecycle information of the underlying Observable completely. The importance of such information was confirmed by the reporter describing their usage of rxjs-spy: The knowledge about the Observable lifecycle, like when it gets subscribed, unsubscribed or completed, helped them to solve problems multiple times. When dealing with higher-order Observables, they value this information even as indispensable.

Finally, we understood that if a problem is hard to replicate within the actual application, the engineers use external sandbox development environments to isolate specific parts of an Observable composition. These allow them to iterate on it faster than it would be possible otherwise.

After the evaluation of all reports and interviews, we speculate that software engineers truly lack debugging tools which can handle RP concepts provided through RxJS. Even though traditional debuggers might help to some extent, they do not provide all the information an engineer is interested in. The last resort in this situation is often the manual augmentation, modification, and extraction of source code as we saw repeatedly. After a look at previous efforts in the area of reactive debugging, we are going to validate our assumption in Section~\ref{sec:study}.


\section{Validation of Interviews and War Stories}
\label{sec:study}

Almost all participants from our interviews and war story reports showed a tendency to manually modify source code with trace logs during the hypothesis instrumentation phase when debugging RxJS code. It is further our own experience that this practice is often not productive since the evaluation and interpretation of trace information tends to be cumbersome and very time-consuming. Also, removing log statements after a successful debugging process might leave new bugs in production code if not done carefully. We identified this technique as one of the primary debugging practices when software engineers work with RxJS-based code.

That is why we saw demand in validating this statement about manual code modification for debugging reasons with an observational study. Our study sought to validate the following hypothesis:

\begin{itemize}
	\item \emph{Hypothesis: If software engineers must solve an RxJS-based problem, then they will instrument the code manually in order to understand its behavior.}
\end{itemize}

\subsection{Study Design}

The subjects for our study were required to have experience in developing applications with RxJS. We did not distinguish between frontend or backend engineers, so in the end, we were able to recruit four subjects willing to participate in our experiment. We were interested to see how the subjects apply debugging techniques they would use in an everyday situation at their jobs. Hence we decided to conduct the experiment in a somewhat uncontrolled environment where the subjects used their own devices with their development environments of personal preference. Our objective for the experiment was communicated as broad as possible to prevent bias: ``We are interested in how \emph{you} debug a problem'' did not mention our hypothesis by intention.

We planned to have a one-hour session for the actual experiment with each subject, followed-up by an unattended quantitative after-action survey. We executed the experiment in two consecutive blocks of 25 minutes each. We provided a ZIP file\footnote{\url{https://github.com/swissmanu/mse-pa1-experiment/archive/v1.0.2.zip}} containing the source code for two frontend web applications implemented using TypeScript and RxJS along with a test suite at the start of a session. Each of these applications was rigged with two to three bugs, which we asked the subjects to identify and fix using whatever debugging techniques they prefer and commonly use. A block was considered as complete once either the test suite signaled all bugs as resolved or the 25 minutes were exceeded. We asked our subjects to act like in a pair programming situation where they ``think out loud'' their thought process. Though we refrained from answering any question related to the ``where'' a bug has to be expected.

A week before the experiment, we sent out the participant briefing document to all of our subjects. We outlined the course of action and provided them with an example ZIP file. This file contained the same setup as the file provided at the experiment and allowed the subjects to get accustomed to things like starting the web applications or running the test suites.

We decided to monitor our subjects' progress remotely using voice chat and screen sharing due to the COVID-19 situation at the time of our study. Furthermore, this allowed us to record the sessions with relatively low technical effort for later evaluation.

The after-action survey\footnote{\url{https://github.com/swissmanu/mse-pa1-experiment/blob/f70102885be86fb2323b9516005e1d6dfeb9795b/after-action-survey-questions.md}} was provided within 24 hours after a subject's participation in the main part of the study. We asked the subjects about (Q1) if they currently use RxJS on or off their jobs, the (Q2) number of years they have experience with RxJS, in (Q3) which field (like frontend, backend or others) they use RxJS and finally (Q4) which tools and techniques they use to debug RxJS-based code. The respective answers allowed us to put the observed actions into perspective and detect potential irregularities in case a subject acted differently as they would have in a ``real'' situation.

\subsection{Study Execution and Results}

After the subjects got themselves accustomed with the application provided and understood its purpose, all of them used the test suite to gather context about what features do not work as expected initially. Further, all of them tried to recreate the failing behavior in the UI manually. We could not observe any of the subjects using external tools, e.g. RxViz, to inspect specific code parts in isolation in later iterations of the debugging process. Though, S2 noted that they would have usually started to decompose the problem into smaller pieces and observe their behavior in specific after the 25 minutes of the second block expired.

While all subjects added manual trace log statements to existing arrow functions or by adding \mintinline{TypeScript}{tap} operators in the instrument hypothesis phase, none of them used additional libraries like rxjs-spy for doing so. S2 and S4 used the traditional debugging tools provided by their browser or IDE to add breakpoints. Both of them commented on the inability of stack traces to interpret RP abstractions as unsatisfying. We could further observe a ``trail-and-error'' approach in later iterations of the debugging process. The subjects started to introduce modifications to the system which they immediately tested against their latest hypothesis. Table~\ref{tab:subject-techniques} provides an overview on the complete collected data regarding used techniques and tools.

\begin{table}
	\caption{Observed practices and tool usage per subject.}
	\begin{tabular}{ p{0.16\linewidth}  p{0.225\linewidth}  p{0.225\linewidth} p{0.225\linewidth} }
		\toprule
		\textbf{Subject} & \textbf{Trace Logs} & \textbf{Debugger} & \textbf{Add. Tools} \\ \midrule
		\textbf{S1}      & \small{X}           &                   &                     \\ \midrule
		\textbf{S2}      & \small{X}           & \small{X}         &                     \\ \midrule
		\textbf{S3}      & \small{X}           &                   &                     \\ \midrule
		\textbf{S4}      & \small{X}           & \small{X}         & \small{Next step}   \\ \bottomrule
	\end{tabular}
	\label{tab:subject-techniques}
\end{table}

Only S4 was able to solve the first problem given as shown in Table~\ref{tab:subject-results}. None of the subjects was able to successfully identify and fix the bugs hidden in the second problem within time.

\begin{table}
	\caption{Results per subject for each presented problem.}
	\begin{tabular}{ p{0.16\linewidth}  p{0.355\linewidth}  p{0.355\linewidth} }
		\toprule
		\textbf{Subject} & \textbf{Problem 1} & \textbf{Problem 2} \\ \midrule
		\textbf{S1}      & \small{Time expired}       & \small{Time expired}     \\ \midrule
		\textbf{S2}      & \small{Time expired}       & \small{Time expired}     \\ \midrule
		\textbf{S3}      & \small{Time expired}       & \small{Time expired}     \\ \midrule
		\textbf{S4}      & \small{Solved}             & \small{Time expired}     \\ \bottomrule
	\end{tabular}
	\label{tab:subject-results}
\end{table}

The survey responses available in Table~\ref{tab:subject-survey} showed that 75\% (S2, S3 and S4) of the subject population had two or more years of experience with RxJS. Where all of them use RxJS to develop frontend applications, S4 declared having used  RxJS for backend development as well. When asked what tools they usually use for debugging, S2, S3 and S4 stated to use the traditional debugger of their IDE. S1 and S3 leverage additional tracing functionality of rxjs-spy, and all four of our subjects use manual log statements.

\begin{table}
	\caption{After-action survey responses per subject.}
	\begin{minipage}{\columnwidth}
	\begin{tabular}{ p{0.12\linewidth}  p{0.06\linewidth}  p{0.14\linewidth} p{0.20\linewidth} p{0.26\linewidth}}
		\toprule
		\textbf{Subject} & \textbf{Q1} & \textbf{Q2}         & \textbf{Q3}               & \textbf{Q4}                             \\ \midrule
		\textbf{S1}      & \small{Yes} & \small{1 year}      & \small{Frontend}          & \small{Trace Logs, rxjs-spy}            \\ \midrule
		\textbf{S2}      & \small{No}  & \small{$>$ 3 years} & \small{Frontend}          & \small{Debugger, Trace Logs}            \\ \midrule
		\textbf{S3}      & \small{Yes} & \small{2 years}     & \small{Frontend}          & \small{Debugger, Trace Logs, rxjs-spy}  \\ \midrule
		\textbf{S4}      & \small{No}  & \small{2 years}     & \small{Frontend, Backend} & \small{Debugger, Trace Logs}            \\ \bottomrule
	\end{tabular}
	\end{minipage}
	\label{tab:subject-survey}
\end{table}

\subsection{Interpretation}

We were able to observe how all subjects predominantly used manual source code augmentation by adding trace logs. Only 50\% of them used traditional debugging utilities in order to inspect the programs state at runtime. All subjects used the new information gained to refine their hypothesis about underlying problems before they started a new iteration in the debugging process. We could not observe the extraction to and reintegration from an external tool. All subjects exhibited the debugging behavior described in our hypothesis.

Even though two subjects stated in the after-action survey to regularly use rxjs-spy for debugging RxJS programs, neither S1 nor S3 made use of this library during the experiment part of the study.

Interviewing professionals, consolidating RxJS hands-on experiences from the war stories, and evaluating the results from our observational study showed us that software engineers use a variety of practices, tools and utilities to debug RP programs. Beside the habit of adding trace logs manually, we saw them evidently trying to answer their debugging hypotheses using traditional, imperative-focused debugger utilities. The later way of debugging was repeatedly commented as unsatisfying as these utilities cannot handle RP constructs and with this, cannot help to detect problems located within these at all. The former way, the introduction of manual log statements, was often described as ``the last resort'' when no other debugging technique helped before. This is because the analysis of log entries gets tedious as the number of those increases.

We heard further how engineers isolate specific Observables from bigger dataflows and how they inspect those in sandboxed environments and visualizers. This helps them understanding lifecycle and value emitting behaviors better and iterate faster in order to resolve problems.

We are able to postulate an answer to our first research question based on this collected information: \textbf{TODO Haben wir wirklich evidenz? Wenig diskutiert?} The biggest challenge for software engineers debugging RxJS-based programs is knowing \emph{when} to apply \emph{what} tool in order to get the \emph{best possible} answer on their currently tested hypothesis. We further claim that, backed by the observation where two subjects knew about rxjs-spy but refrained from using it nonetheless, it is not enough to \emph{know} about the existence of a specific tool for a particular debugging situation. Such a tool should rather offer itself at the ``right'' moment so the engineer can benefit from its features. An example for such a behavior is the seamless integration of asynchronous call stacks in Google Chromes JavaScript debugger\cite{chromeasync}: Even though code was executed ``outside'' of the current call stack, the debugger shows these asynchronous stack frames as they were actually part of it.

Before we elaborate on a solution in order to overcome the challenges identified with RQ1, we are going to present a selection of RP specific debugging utilities available today.

\section{Discussion of Previous Efforts}
\label{sec:discussion}

\subsection{rxjs-spy}

\emph{rxjs-spy}\cite{rxjsspy} is a logging library specialized on RxJS observables. Once an observable is tagged with an arbitrary string identifier, the library can generate trace logs when a value is emitted as well as when individual lifecycle events occur (i.e. subscribe, unsubscribe, complete and error). Ideally, tagged Observables are created during development when the dataflows are composed for the first time. Like the \mintinline{TypeScript}{tap} operator in Listing~\ref{lst:rxjs-debugging}, the \mintinline{TypeScript}{tap} operator in Listing~\ref{lst:rxjs-spy-tag} on Line~3 is completely transparent to the actual dataflow.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		import { create } from 'rxjs-spy';
		import { tag } from 'rxjs-spy/operators';

		const spy = create(); // Create monitor
		spy.log(/multiply/);  // Log tags matching
		                      // RegEx /multiply/

		interval(1000).pipe(
		  map(i => i * 2),
		  tag('multiply'),    // Tag with "multiply"
		  map(i => i - 1),
		  tag('subtract')     // Tag with "subtract"
		  take(2)
		).subscribe();
	\end{minted}
	\caption{Application of rxjs-spy using its \mintinline{TypeScript}{tag} operator on Line~10 and 12.}
	\label{lst:rxjs-spy-tag}
\end{listing}

The dataflow configuration in Listing~\ref{lst:rxjs-spy-tag} will produce a trace log as shown in Listing~\ref{lst:rxjs-spy-log}.

\begin{listing}[H]
	\begin{minted}{Typescript}
		Tag = multiply; notification = subscribe
		Tag = multiply; notification = next; value = 0
		Tag = multiply; notification = next; value = 2
		Tag = multiply; notification = unsubscribe
	\end{minted}
	\caption{rxjs-spy execution trace log generated by default monitor in Listing~\ref{lst:rxjs-spy-tag} on Line~4.}
	\label{lst:rxjs-spy-log}
\end{listing}

Additional features are available through the debuggers console interface. E.g., a tagged Observable can be paused so values get collected rather than being emitted immediately. The engineer can then emitted these values one after another manually or resume all of them at once.

\subsection{rxfiddle}

\emph{rxfiddle} as proposed by Banken et al.\cite{10.1145/3180155.3180156} is the first reference implementation of their RP debugger architecture for the ReactiveX API specification. They describe a software design consisting of two independent components: The (i) \emph{host instrumentation} augments a ReactiveX API implementation to emit events at runtime (e.g., emitting a value or lifecycle events) and forwards them to the second component. The (ii) \emph{visualizer} interprets the events and displays them along two dimensions: The StoryFlow graph\cite{YWu2013a} shows when an Observable is created and how it interacts with other Observables, whereas a marble diagram visualizes the values emitted over time for every Observable.

The reference implementation supports event processing for the (outdated) RxJS major versions 4 and 5 only and is available as an online application\footnote{\url{https://rxfiddle.net/}}. A proof-of-concept implementation which can be executed on a local computer is available through the projects Git repository\footnote{\url{https://github.com/hermanbanken/RxFiddle}}.

\subsection{RxViz}

\emph{RxViz} is a visualizer utility available online\footnote{\url{https://rxviz.com/}}. It is an ``animated playground for Rx Observables''\cite{rxviz} and allows the visualization of RxJS observables using marble diagrams. Engineers implement or copy-paste dataflows in an editor window using JavaScript. This code is then used to generate a diagram over a configurable time interval. The diagrams are rendered immediately and are available as downloadable SVG files.

\subsection{Reactive Inspector}

In the paper ``Debugging for Reactive Programming''\cite{10.1145/2884781.2884815}, Salvaneschi et al. elaborate on the necessity of RP debugging tools which can interpret its specific dataflow abstractions. Based on their research, developed a reactive debugger named \emph{Reactive Inspector}. This plugin for the Eclipse IDE provides reactive debugging functionality for programs using the REScala RP runtime.

The plugins core feature is the visualization of the dataflow graph. This representation of the dataflow provides a UI to add a new kind of breakpoint, the ``reactive breakpoint,'' to individual nodes in the graph. With them, the execution of the program can be interrupted e.g., when a node retains a specific value or a particular lifecycle event takes place.

Along with the RP specific debugging features, Reactive Inspector experiments with the omniscient debugging concept: The time travel functionality allows to record dataflows. These recordings can then be replayed and inspected at a later time without actual re-execution of the program.

\subsection{Comparison}

\textbf{TODO REWRITE HERE}

Specialized utilities are aware of RP runtime environments and help software engineers to interpret its state better than before using sole traditional debugger tools. Most of them provide a way to represent the dataflow graph either graphically (Reactive Inspector, rxfiddle) or in textual form (rxjs-spy). They visualize the data flowing through the graph over time in marble diagrams (rxfiddle, Rx Visualizer) or directly in a visual graph representation (Reactive Inspector). Whereas Reactive Inspector for REScala provides an ``all-in-one'' solution with reactive breakpoints, omniscient debugging capabilities, and full IDE integration, the RxJS-related tools provide smaller, differentiated feature sets in contrast. Most of them require the engineer to extract code from its origin (rxfiddle, Rx Visualizer) or call for manual code preparation or modification (rxjs-spy).

\begin{table}[H]
	\caption{Feature Matrix for Discussed RP Debugging Tools}
	\begin{tabular}{@{}lllll@{}}
	\toprule
					   & \textbf{UI} & \textbf{Integration}                                               & \textbf{Flow Control}                                              & \textbf{RP Runtime} \\ \midrule
	Reactive Inspector & Visual      & Eclipse IDE                                                        & Full                                                               & REScala             \\ \midrule
	rxfiddle           & Visual      & Web App                                                            & None       & RxJS                \\ \midrule
	rxjs-spy           & Textual     & \begin{tabular}[c]{@{}l@{}}Browser Console\\and Code\end{tabular} & Limited & RxJS                \\ \midrule
	Rx Visualizer      & Visual      & Web App                                                            & None       & RxJS                \\ \bottomrule
	\end{tabular}
	\label{tab:compare-tools}
\end{table}

\section{Future Work}
\label{sec:future}

\textbf{TODO REWRITE HERE}

Having the main challenges for engineers identified when debugging RxJS-code, we can propose areas to improve on now and resolve RQ2 by doing so.

\subsection{Improve User Experience}

Our overall goal is to support engineers during the process of understanding the inner workings of the RxJS dataflow graph. Existing tools and libraries provide some help, though often struggle by means of the UX: Trace logs with relevant information like life cycle events do improve the debugging process as we saw. Digging through hundreds of log entries containing information of multiple Observables gets tedious quickly, however. Filter and search functionalities help but cannot resolve all UX challenges.

A graphical representation of the dataflow graph is better suited to show dependencies within the model then textual trace logs. Previous research showed that the sheer amount of nodes in an elaborate graph is hard to visualize effectively\cite{10.1145/3180155.3180156} on one side, on the other also not easily implement efficiently as well.

We intend to find a solution that combines the power of textual trace logs with the ease-of-use of graphical visualizations for RxJS dataflow graphs. We want this solution to handle small as well as large graphs.

\subsection{Automatic Code Augmentation}

RP code needs to be augmented with additional functionality so telemetry data can be collected. Previous solutions do this using code weaving\cite{10.1145/2884781.2884815} or similar techniques\cite{10.1145/3180155.3180156}. For engineers themselves though, this is often a manual process. We want to make the manual modification of production source code obsolete. rxfiddle proofed such mechanisms to work with RxJS 4 and 5, hence we intend to bring this feature to version 6, and possibly the upcoming major version 7 as well.

\subsection{Integration}

75\% of our observational study participants used the debugging tools integrated into their browser or IDE. Even though some of them stated to know additional external utilities in the after-action survey, none of them went that far and used them during the one-hour session.

We understand the observed behavior as evidence for a hurdle preventing engineers from using specialized RP debugging utilities. In order to reach more software engineers with RP domain-specific debugging tools, we want to provide a potential solution as tightly integrated with the developer tools of the browser or an IDE as possible.

\subsection{Other Areas of Improvement}

There are many more areas which could be worth a further look in the future. E.g., the combination of controlling the program execution based on breakpoints within the dataflow graph or concepts of omniscient debugging are exciting fields as well. We will focus on the presented three topics for our future work, but keep additional ideas in a backlog for the case time allows additional iterations.

\section{Threats to Validity}
\label{sec:threats}

\textbf{TODO REWRITE HERE}

We worked with 14 professional software engineers while writing this paper. Five interview partners and five war story reports helped us build the foundation for a later observational study with four participants.

While we claim that nine interviewees and reporters have been an appropriate number of peers for collecting the initial data, we are aware that our four subjects for the observational study lead to a result lacking significance.

More time given, we suggest conducting the study with a bigger population again to obtain a result with higher significance and providing more insight into how engineers debug RxJS-based code. Doing so would possibly require a statistical evaluation of these results.

Furthermore, this was the first time we designed an observational study of this kind. Though we carefully peer-reviewed the study design with our advisor, we cannot claim the design and its execution to be flawless. E.g., we would use a commonly known business domain for both problems presented to the subjects. This would allow them to understand the functionality of the application in front of them quicker and focus more on resolving the task given.

\section{Conclusion}
\label{sec:conclusion}

\textbf{TODO REWRITE HERE}

We have talked to multiple people in order to understand how software engineers apply RP using RxJS for building applications. We have looked into how they debug their applications and could identify several struggles they have to overcome in this process. We could prove that the engineers inevitably tend to modify their source code once they do not understand how the RP runtime propagates values through its internal dataflow graph by observing professionals in an observational study.

On the way, we elaborated on previous, academic as well as non-academic efforts in the field of reactive debugging. We presented a selection of tools which leverage on their knowledge about the internal workings of RP runtime environments.

With \emph{UX}, \emph{Automatic Code Augmentation} and \emph{Integration} we finally proposed three concepts where we intend to improve on a software engineers debugging experience, hence answering our second research question RQ2. We plan to work further on these topics within the scope of our master's studies research and, eventually, answer our last research question RQ3.


\begin{acks}
	We would like to
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}

\end{document}