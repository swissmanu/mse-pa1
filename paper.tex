\documentclass[12pt,a4paper]{article}
\usepackage{ccicons}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{graphicx}

\setminted{autogobble=true, tabsize=2, linenos=true, frame=single, breaklines=true}

\newcommand{\version}{v0.4 Draft}

\begin{document}
\begin{centering}

	\Large{Workshop Paper}
	\par
	\Huge{Debugging of RxJS-based Frontend Web Applications}
	\par
	\vspace{2ex}

	\normalsize{
		Manuel Alabor\\
		Supervised by Prof. Dr. Markus Stolze\\
		\par
		\vspace{2ex}
		HSR University of Applied Sciences Rapperswil\\
		\par
		\vspace{2ex}
		\today{} (\version)
	}
	\par
	\vspace{2ex}

	\begin{quotation}
		\small{
			\noindent\textbf{Abstract}---\input{./abstract.tex}
		}
		\par
		\vspace{4ex}
	\end{quotation}
\end{centering}

\section{Introduction}

An application providing a user interface (\emph{UI}) can be seen as a reactive application (\emph{RA})\cite{7827078}: It handles a continuos flow of user- and system-created events in order to give the user a representation of the applications state in a timely fashion. One way of implementing reactive behavior is the Observer design pattern\cite{gamma1995design} where an observer (e.g. the UI rendering code) is repeatedly informed about changed application state. With Reactive Programming (\emph{RP}), another way to implement RAs is trending. RP is enabled by language extensions, runtime environments and domain specific languages (\emph{DSL}) and based on functional programming (\emph{FP}) principles. With RP, software engineers describe declaratively how data flows through a RA, how that data depends from each other and how it is to be transformed over time.

Utilities to debug the runtime behavior of a program are essential to software engineers today. They help to understand the inner workings of unknown source code or allow to track down a problem which may lead to an unexpected failure in a particular situation. Debugging utilities took different forms over time: From interpreting memory dumps, manually adding print statements to trace program execution up to the point where specialized debugging programs can interrupt a running process and interact with it on a low level, software engineers have access to versatile debugging tools at present day.

Debuggers available in IDEs and the developer tools of a web browser\footnote{\url{https://developer.mozilla.org/en-US/docs/Tools/Debugger}} today are specialized to work with imperative, control-flow oriented programs. E.g. when an engineer wants to know which part of the program called a particular function, the stack trace gives a clear answer to this question. Assuming a data-flow oriented program implemented using RP, the question, which transformation was executed right before another cannot be answered using a stack trace: A breakpoint within the transformation will not point to its logical predecessor, it will lead to the internals of the RP runtime instead.

This lack specific knowledge about RP concepts in traditional debugging utilities does often end in time consuming debugging sessions as we can confirm from our own experience. Previous research has looked into this field \cite{10.1145/2577080.2577083} \cite{10.1145/2884781.2884815} \cite{10.1145/3180155.3180156} over the past years already. We will revisit their results in this paper and elaborate on the particular challenges of debugging RAs using RxJS for frontend web applications.

Transcripts of informal interviews and ``war stories'' collected from multiple practitioners will give insight in the challenges they face in their day-to-day jobs. We will validate their statement in a controlled experiment and answer our first research question:

\begin{itemize}
	\item \emph{RQ1: What challenges do frontend engineers face when debugging RxJS-based code?}
\end{itemize}

In response to this, we will present three potential solutions to resolve previously identified problems and give an answer on the second research question:

\begin{itemize}
	\item \emph{RQ2: How can the experience of frontend engineers during debugging of RxJS-based code be improved?}
\end{itemize}

The future implementation and validation of these proposals leads to our third research question which will be part of future work not part of this paper:

\begin{itemize}
	\item \emph{RQ3: What is the impact of a proposed solution on the debugging experience of a frontend engineer?}
\end{itemize}

We will conclude this introductory section with the clarification of important terms. Section~\ref{sec:interviews} presents the interview results along with the collected war stories and formalizes two recurrent challenges. With Section~\ref{sec:discussion}, we will have a look at current and previous research regarding debugging of reactive applications as well as specific tooling. We are going to validate presented challenges against currently available tools within Section~\ref{sec:study}, show threats to validity of our work in Section~\ref{sec:threats} and finally end with an outlook on future iterations.

\subsection{Reactive Applications}

Salvaneschi et al. \cite{7827078} define a RA as a computer program which processes a continuos, indefinite and ever-changing flow of data. Think of a spreadsheet application\cite{10.1145/2501654.2501666} that links the values of cells to other cells using formulas. Once a cell is changed, it is the task of the application to update all dependant cells accordingly and cascade the updates throughout the model. This data-flow based type of application is contrasted by program-flow based applications which consume and process one piece of input while producing a one-off output like an image format conversion program that transforms between HEIF\footnote{\url{https://nokiatech.github.io/heif/technical.html}} and JPEG image formats.

The classification schema by Salvaneschi et al. \cite{7827078} divides RAs into three types: A (i) \emph{synthetic application} transforms and processes streams of information. RAs are prevalent in the area of UIs further: They can be identified as (ii) \emph{interactive applications} and help to describe and implement (iii) \emph{graphical animations}.

\subsection{Reactive Programming}

Various ways of implementing RAs emerged over time. The Observer design pattern \cite{gamma1995design}, originated in Object Oriented Programming \emph{(OOP)}, is a pattern we can find in many of todays API implementations\cite{alabor:2019:reactiveappllications} allowing reactive behavior. Functional Programming \emph{(FP)} shines with specific reactive language extensions like Fran (Haskell) \cite{10.1145/2501654.2501666} or more recently REScala (Scala) \cite{10.1145/2577080.2577083}.

Reactive programming \emph{(RP)} is a declarative programming paradigm. Where engineers use imperative programing languages to tell a program every step \emph{how} to do something, a declarative language allows to describe \emph{what} wants to be achieved. The languages runtime system then figures out a way to satisfy that given description. RP environments specifically provide abstractions to describe a data-flow and dependency graph which is used to transform and direct data at runtime.

An RP environment provides (i) language constructs to describe mentioned graphs, often in form of a DSL\cite{10.1145/2577080.2577083}. At program runtime, a (ii) runtime system takes care that changed values are propagated through the graph, transformations are recomputed where necessary and a consistent application state is maintained.

\subsection{Debugging Concepts}

We divide debugging concepts roughly into three categories: Traditional \textbf{imperative-focused debuggers} provide basic functionality to interact with programs at runtime: Once code execution is paused (i.e. using a breakpoint at a given statement), we gain access to the current call stack and the values assigned to variables of a given frame. Manual control of the program execution allows to inspect its behavior step by step as well as assigning new values to variables ``on-the-fly''.

Where individual transformations of an RP based program can be inspected using traditional debuggers, they fall short in understanding the underlying model of the data-flow graph. In fact, RP provides its own challenges to debuggers: Call stacks expose internal invocations of the RP runtime system rather than e.g. the predecessor transformation according to the data-flow graph. Further, breakpoints can only be used on the imperative parts of transformations and lack the functionality of interrupting execution when the RP runtime hits a specific node within the graph. A \textbf{reactive debugger} has knowledge about the internal model of a RP runtime system. It leverages on it and provides specialized tools e.g. to navigate or visualize the data-flow graph \cite{10.1145/2884781.2884815} \cite{10.1145/3180155.3180156} \cite{rxviz}. We will have a closer look to available reactive debugger solutions.

The traditional as well as the reactive debugger works with the \emph{current} state of a programs execution only. They lack knowledge about what happened before or what is going to happen in the future. This shortcoming is tedious, especially when debugging a problem depending from multiple complex circumstances in a system. An \textbf{omniscient debugger} \cite{5287015} \cite{DBLP:journals/corr/OCallahanJFHNP17} does not interact with the executed program directly. Instead, it records runtime telemetry and provides an interface for later inspection. Engineers can ``time travel'' back and forth through the program execution trace without the hassle of reconstructing a given failure situation over and over again. This concept comes with its own set of challenges though: Once decided \emph{what} information should be recorded (everything, only specific parts of the program, one thread, multiple threads, \dots), demands on storage performance and capacity increase while the pool of collected data grows. As a result, user experience (\emph{UX}) concepts need to be aligned for the engineers being able to interact with the sheer amount\cite{5287015} of information efficiently.

\subsection{ReactiveX and RxJS}

``Reactive Extensions'' (\emph{ReactiveX}) is an open source project. Its members and contributors defined a generic description of an RP API. They further provide reference implementations of this API along with RP runtime environments for various programming languages like Java, C\# and JavaScript\footnote{\url{http://reactivex.io/languages.html}}. ReactiveX summarizes the API as ``\dots a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming''\cite{reactivex}. The core concept of the API specification is the Observable\footnote{There is no known relation between ReactiveX' concept of the Observable and the deprecated Java class \href{https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Observable.html}{\mintinline{TypeScript}{java.util.Observable}}.}: An Observable can be composed and linked (``piped'') with other Observables. It has the ability to push (``emit'') values to its dependents. Multiple depending Observables form and describe a data-flow graph eventually. A multitude of operators allow the transformation of values and (higher-order) Observables. Values emitted from an Observable can be subscribed to at any point which is closely related to the Observer design patterns \mintinline{Java}{attach} method.

RxJS is the reference implementation of the ReactiveX API specification for JavaScript and TypeScript. It is used thoroughly by large projects like Angular\cite{angualrrxjs}. Listing \ref{lst:rp-with-rxjs} shows an example of RP using RxJS in TypeScript.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		import { of } from 'rxjs';
		import { filter, map } from 'rxjs/operators';

		of('hello', 'foo', 'world').pipe(  // Create Observable
			filter(s => s !== 'foo'),        // filter Operator
			map(s => s.toUpperCase())        // map Operator
		).subscribe(console.log)           // Emits: HELLO, WORLD
	\end{minted}
	\caption{Basic RxJS Example}
	\label{lst:rp-with-rxjs}
\end{listing}

\section{Interviews and War Stories}
\label{sec:interviews}

We have worked together with 15 professional software engineers during the process of answering RQ1. On the way of finding our interview partners and war stories reporters, we noticed it to be a challenge on its own to find people which understand themselves as users of RP and related technologies. E.g. even though Angular makes heavy use of RxJS, we will see that many engineers do not interact with its abstractions directly in order to build simple UIs. In the end we were able to gather interesting statements nonetheless which we are going to present in this section.

\subsection{Informal Interviews}

We organized informal interviews which allowed us to gain first insight in how software engineers work with RP in their daily jobs. We talked to six engineers and asked them about the technologies they use, what their personal experience with RP was, what they most liked and most disliked about it.

Four of our interview partners stated to currently work or more recently have worked with RxJS in conjunction with Angular and/or ngrx\footnote{\url{https://ngrx.io/}} to develop frontend web applications. By being the creator of a visualizer for RxJS Observables, the fifth interviewee was a proficient RxJS user. Our sixth interview partner finally was a backend engineer which used akka-streams\footnote{\url{https://akka.io/}} in Scala to model data-flows for a WebSocket-based\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API}}, reactive API layer serving a web frontend application.

All of the interviewees referred to RP with an overall positive experience. We heard statements like ``RP is a good way for composing multiple data sources'' and ``having a statically typed language combined with RP already guarantees some kind of basic correctness of my program'' repeatedly throughout all sessions. Hence a big strength of RP seems to be the ability to describe complex data-flow constructs using a specialized DSL. The learning curve can be steep for a novice engineer though: ``Being already challenged with new concepts of Angular and ngrx, I noticed RxJS concepts and operators to be hard to grasp in addition on top'' an interview partner giving lectures in frontend web application development stated further.

It was interesting to hear that, especially in the area of developing web applications using Angular, our partners seemed not to have to work with pure RxJS code often. E.g. when using ngrx for state management, ``the framework takes care that you do not have to interact with Observables on your own, but leverages greatly on their potential behind the scenes''. As soon as our interviewees had to extend built-in functionalities with their own features, e.g. a new effect\footnote{\url{https://ngrx.io/guide/effects}}, all of them valued the possibility to interact with underlying Observables highly.

When asked explicitly about what they dislike the most about RP, all interview partners with no exception emphasized the debugging process of an RP application as a big nuisance. The fact that our interviewees remembered the search for a bug as something negative did not surprise us, hence a bug is usually something negative afflicted. What did alarm us though was the fact that statements like ``In 99\% of all cases, I add console.log statements manually and run the program over and over again, trying to understand what is happening'' were prevalent and gave insight in \emph{why} our interview partners dislike RP debugging in particular. Multiple interviewees mentioned the Redux DevTools\footnote{\url{https://chrome.google.com/webstore/detail/redux-devtools}} as helpful when debugging Angular/ngrx applications nonetheless. Further, one single partner mentioned marble diagrams as very valuable in order to understand how an RxJS Observable works, no matter if during development or when debugging code. Marble diagrams are a way to visualize and describe the value-emitting behavior of an Observable over time. They are accepted throughout the ReactiveX community for documentation\cite{marblediagrams} and testing reasons\cite{marbletesting}.

\begin{figure}[H]
	\centering
	\input{figures/marble-diagram.pdf_tex}
	\caption{A Marble Diagram visualizing the Observable in Listing~\ref{lst:rxjs-step-controls}}
	\label{fig:marble-diagram}
\end{figure}

\subsection{War Stories}

After we built a first intuition for how software engineers work with RP by evaluating the informal interviews, we were interested in more RxJS-specific, hands-on experiences. We asked the engineering community via Twitter\footnote{\url{https://twitter.com/swissmanu/status/1242429409208029185}} about their personal, most recent RxJS debugging war story and sent out various emails with the same request. After reaching out, we were able to collect five responses: One by a RxJS core team member, two from Angular Google Developer Experts and another two reports by two software engineers building web and mobile applications using React and RxJS which includes the author of this paper.

The reports provided us diverse perspectives on various areas of software development using RxJS. One of the reporters focused on how they built code which had improved on testability over the recent versions of RxJS: ``[\dots] in the beginning, it was very hard to write async tests and I did not like it. I really disliked that once you started to test async code you were forced to pass a TestScheduler''. Allowing to pass the scheduler explicitly as parameter forced them to introduce code which was only necessary for testing reasons they stated further. With its current major version, RxJS 6 improved heavily on the  \mintinline{TypeScript}{TestScheduler}. The runtime environment itself can now be augmented with the scheduler which results in cleaner code.

Even though the share of non-productive, testing-related code necessary to build mature RxJS-based applications was mentioned to have decreased today, multiple of our reporters mentioned the common practice of manually modifying production code during debugging sessions, hence confirming earlier statements from our informal interview partners. One engineer described a specific scenario where they suspected a problem within a complex Observable composition: Having multiple asynchronous, remote data sources, they used Observables to model the dependencies between them and implemented computations on their results as operators. On top, each data source could re-emit updated versions of previously requested information any time. Though tested thoroughly, after a week in production the first of many bugs was reported: ``Figures were changing multiple times (where I expected them to change once), other numbers were not updated at all'' they told us. The browsers debugger tools and its breakpoints did not help much since the operators were executed several multiple times and some parts of the stream were impossible to grasp, even with conditional breakpoints. ``I started to inspect the flow [\dots] with console.logs and later also using tags from rxjs-spy'', hence manually augmenting the code with trace logs. After the time consuming log analysis, they finally were able resolve the bug. The log statements added were removed in the aftermath, though the rxjs-spy related code was left in the Observable stream in case they might be needed again in the future. (We will elaborate on the functionality of rxjs-spy in Section~\ref{sec:discussion} more in-depth.)

In a related war story, another engineer disclosed similar practices using  external tools: ``It took quite some time to get it right and one of the most invaluable tools proved to be Stackblitz which gave us ability to quickly create smaller working examples and iterate on them.'' Stackblitz\footnote{\url{https://stackblitz.com/}} is a full JavaScript development environment available online. They used this sandboxed setting to run, debug and iterate on selected pieces of a larger Observable stream. Even though the final result had to be integrated back into the actual application, the extra effort was worth the result the engineer concluded in their report.

A final story described yet another variation of the application of an external tool: Rather than using a dedicated sandbox to develop pieces of a more complex system, this engineer used Rx Visualizer, an online visualization utilities to generate previously presented marble diagrams from real code. Like in the report before, it was necessary to extracted code from the actual applications code base. But once done, the diagrams helped a lot in order to understand when values were emitted, when subscriptions changed and when Observables completed: ``Marble diagrams were a huge help to dig into detailed runtime and life cycle behaviors of the Observables.''.


\subsection{Wrap Up}

The overall sentiment in both the informal interviews as well as the reported war stories in regards of RP with RxJS was positive. The software engineers value how they can describe data flows using a DSL, even though the learning curve was perceived as steep. We heard some interesting reports how RxJS is applied in a daily development environment: Marble diagrams help to understand  an Observables behavior and are useful to implement tests. Large frameworks like Angular hide some of the complexity of RxJS but allow engineers to make use of its full power once the provided functionality needs to be extended.

Most participants considered a statically typed language like TypeScript a fundamental necessity which allowed them to implement data-flow graphs with a minimal, formal correctness. We noticed throughout all reports that once the engineers were required to interact with the Observable graphs at runtime, they felt kind of ``lost'' and lacking ``the right tool'' to work within the context of RP.

% TODO

The interpretation of the combined interview and war stories data gives us an idea about two main challenges software engineers have to overcome during debugging activities of RxJS-based code:

It is crucial to the engineers to \textbf{understand data flows}  within the Observable graph. Questions like ``Which source emitted a value at what time?'' or ``What is the result of a specific transformation?'' are common in this context. Once a program fails, software engineers need to \textbf{rely on traditional debugger tools}. Though providing help to some extent, the tools lack of specific knowledge about the RP runtime environment adds some oddities to the debugging process: The (i) functionalities allowing step-wise navigation through the code does not respect the RP context. Assume we have set a breakpoint at \mintinline{TypeScript}{i * 2} on line~2 of Listing~\ref{lst:rxjs-step-controls}. Once the debugger hits the breakpoint and we instruct it to ``Step Over'', the debugger will lead us to the internal implementation of the \mintinline{TypeScript}{map} operator instead to line~3. (ii) Stack traces include information about the invocation of internal functions which, most of the time, do not provide any valuable information to the engineers further.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		interval(1000).pipe(      // Increasing numbers with 1s delay
		  map(i => i * 2),        // Breakpoint on i * 2
		  map(i => i + 1),
		  take(4)
		).subscribe(console.log); // 1, 3, 5, 7 & complete
	\end{minted}
	\caption{RxJS Observable With Breakpoint Within a \mintinline{TypeScript}{map} Operator}
	\label{lst:rxjs-step-controls}
\end{listing}


\section{Discussion of Previous Efforts}
\label{sec:discussion}

Our work is not the first approach on understanding and improving on the struggles software engineers have to overcome when working on RP code, either with or without RxJS. We are going to present four of this tools in this section. This list is not meant to be exhaustive. It contains tools we either got to know during our research because they were mentioned in one of the interviews or we worked with them personally in the past.

\subsection{Reactive Inspector}

Salvaneschi et al. did focus their research heavily on RP during the mid 2010s. Beside the creation of REScala in 2014 \cite{10.1145/2577080.2577083}, an RP DSL and runtime for the Scala programming language, they looked into the debugging habits of software engineers as well. In the paper ``Debugging for Reactive Programming'' \cite{10.1145/2884781.2884815}, Salvaneschi et al. elaborate on the necessity of RP debugging tools which can understand the specific language abstractions. With the plugin Reactive Inspector for the Eclipse IDE, they provide a debugger which understands the RP language abstractions of REScala. One of its main features is the visualization of the internal dependency graph. The new class of  breakpoints, the ``reactive breakpoints'', builds upon the visualized graph as well: They do not depend on a specific line of code or statement rather then on a specific node in the graph. The execution of the program can be interrupted e.g. once a node retains a specific output value or an event of interest takes place in the runtime. Along with the RP specific debugging features, Reactive Inspector implements omniscient debugging concepts as well: Time travel allows to record and replay runtime behavior at a later time without reexecution.

Salvaneschi et al. claim\cite{10.1145/2577080.2577083} the architecture behind \emph{Reactive Inspector} to be flexible enough to be used with different RP runtime environment as well.

\subsection{rxfiddle}

rxfiddle proposed by Banken et al. is the first reference implementation of their RP debugger architecture for the ReactiveX API specification described in their paper ``Debugging Data Flows in Reactive Programs'' \cite{10.1145/3180155.3180156}. The design defines two independent parts: The (i) \emph{Host instrumentation} instruments a ReactiveX implementation to emit events at runtime (e.g. when an Observable is created or subscribed) which get collected. The (ii) \emph{Visualizer} component interprets these events and presents them along two dimensions: The StoryFlow graph \cite{YWu2013a} shows when an Observable is created and how it interacts with other Observables. An additional marble diagram for every Observable is used to display the values it emits over time.

The reference implementation supports event collection for RxJS-based code in version 4 and 5. It can either be used on a local development machine on existing projects or by copying code snippets to the online available.

The architectural design of \emph{rxfiddle} is similar to the one \emph{Reactive Inspector}: Banken et al. provide a system where different RP runtime environments should be able to be attached to the Visualizer easily.


\subsection{rxjs-spy}

Software engineers tend to augment their code with additional log trace statements in the situation where they have to track down a problem as we saw earlier. rxjs-spy\cite{rxjsspy} intends to improve on this by introducing the \mintinline{TypeScript}{tag} operator. Instead of adding log traces at debug-time, ``tagged'' Observables are created right at the moment the Observable itself is defined. A tag as shown in Listing~\ref{lst:rxjs-spy-tag} does not influence runtime behavior at first.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		interval(1000).pipe(
		  map(i => i * 2),
		  tag('multiply'),
		  map(i => i - 1),
		  take(2)
		).subscribe();
	\end{minted}
	\caption{Usage of \emph{rxjs-spy} \mintinline{TypeScript}{tag} Operator on Line 3}
	\label{lst:rxjs-spy-tag}
\end{listing}

Later, rxjs-spy can be advised to log events such as subscribe, emit, error, complete and unsubscribe of matching tags directly to the console without touching any Observable code at all. It is worth to mention that manual log traces, without additional effort, only show values flowing by. The additional events logged by rxjs-spy were noted invaluable in the interviews presented earlier as well as in our own experience.

\begin{listing}[H]
	\begin{minted}{Typescript}
		Tag = multiply; notification = subscribe
		Tag = multiply; notification = next; value = 0
		Tag = multiply; notification = next; value = 2
		Tag = multiply; notification = unsubscribe
	\end{minted}
	\caption{Trace log generated by \emph{rxjs-spy} \mintinline{TypeScript}{tag} from Listing~\ref{lst:rxjs-spy-tag}}
	\label{lst:rxjs-spy-log}
\end{listing}

Additional features are available through the debuggers console interface. A tagged Observable can be paused so it collects incoming values. They can then be emitted one after another or resumed at once.

\subsection{Rx Visualizer}

The \emph{Rx Visualizer}\cite{rxviz} is a utility available online in the browser. It is an ``animated playground for Rx Observables''\cite{rxviz} and allows to visualize snippets of RxJS code using marble diagrams. Diagrams are generated over a given, fixed time and can be saved as SVG\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/SVG}}.

The visualizer helps to understand the behavior of a specific part of an Observable stream in a sandboxed environment.

\subsection{Comparison}

Specialized utilities are aware of RP runtime environments and help software engineers to interpret its state better than before using sole traditional debugger tools. Most of them provide a way to represent the data flow graph either graphically (Reactive Inspector, rxfiddle) or in textual form (rxjs-spy). They visualize the data flowing through the graph over time in marble diagrams (rxfiddle, Rx Visualizer) or directly in the visual graph representation (Reactive Inspector). Some like Reactive Inspector for REScala provide an ``all in one'' solution with breakpoints, omniscient debugging capabilities and full IDE integration whereas the RxJS-based tools have a more specific feature set: They usually work outside of an IDE and/or need manual code instrumentation like rxjs-spy.

\textbf{TODO Compare im Table?}


\section{Study Design}
\label{sec:study}

\begin{itemize}
	\item Hypothesis
	\item Use prev section to build experiments using existing tooling
	\item Validate stories and interviews
\end{itemize}

\section{Future Work}
\label{sec:future}

\begin{itemize}
	\item Pick up results from war stories and experiment
	\item Propose one solution per challenges
	\item Sketch how this could look like
	\item This answers RQ2
\end{itemize}

\section{Threats to Validity}
\label{sec:threats}

\begin{itemize}
	\item Informal interviews/war stories only
	\begin{itemize}
		\item Describe background of interview partners
		\item Only 4 Participants in experiment
		\item Code in experiment carefully crafted... Though is it representative?
		\
	\end{itemize}
\end{itemize}

\section{Conclusion}
\label{sec:conclusion}

\begin{itemize}
	\item Recap Past Developments in RP Debugging
	\item Recap proposed solution
	\item Whats next in PA2?
	\item Whats the vision for the thesis?
\end{itemize}


\bibliographystyle{splncs04}
\bibliography{bibliography.bib}

\section*{License}
\ccby\thinspace\thinspace This work is licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.
\end{document}