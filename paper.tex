\documentclass[12pt,a4paper]{article}
\usepackage{ccicons}
\usepackage{hyperref}
\usepackage{minted}

\setminted{autogobble=true, tabsize=2, linenos=true, frame=single, breaklines=true}

\newcommand{\version}{v0.2 Draft}

\begin{document}
\begin{centering}

	\Large{Workshop Paper}
	\par
	\Huge{Debugging of Modern RxJS-based Frontend Web Applications}
	\par
	\vspace{2ex}

	\normalsize{
		Manuel Alabor\\
		Supervised by Prof. Dr. Markus Stolze\\
		\par
		\vspace{2ex}
		HSR University of Applied Sciences Rapperswil\\
		\par
		\vspace{2ex}
		\today{} (\version)
	}
	\par
	\vspace{2ex}

	\begin{quotation}
		\small{
			\noindent\textbf{Abstract}---\input{./abstract.tex}
		}
		\par
		\vspace{4ex}
	\end{quotation}
\end{centering}

\section{Introduction}

The debugger is an essential tool to get a deeper understanding of the runtime behavior of a software system. Software engineers use it to understand why particular circumstances lead to an unexpected failure during execution or to step through unknown program code in order to get themselves accustomed with it.

IDEs as well as the developer tools of modern web browsers provide battle-tested debugger utilities \footnote{\url{https://developer.mozilla.org/en-US/docs/Tools/Debugger}} to inspect frontend application code at runtime. With an imperative programming model in mind, they let the user jump from program statement to statement, stop execution upon hitting a breakpoint while having a closer look at the values currently assigned to variables. By the time they are even able to preserve call stacks for asynchronously executed code which was a hassle before \footnote{\url{https://developers.google.com/web/tools/chrome-devtools/javascript/reference\#call-stack}}.

Modern web frontend applications use the browser for rendering sophisticated, reactive user interfaces. Reactive applications contrast more traditional computer programs: Where i.e. the conversion from one image format to another is a one-off process with clearly defined start and end point, a reactive application handles a continuos flow of stimuli: While moving the cursor over UI elements, the application provides steady feedback to the user on the display.

Todays state of the art debugger tools can be used to work with reactive applications as well. (Conditional) breakpoints are essential to interrupt the code execution at the right moment to inspect the inner workings of the reactive program. As we will see later though, software engineers tend to fall back to a log-based debugging approach when the complexity of a system increases.

% Previous research \cite{10.1145/3180155.3180156} \cite{10.1145/2884781.2884815} in the field of debugging for reactive applications as well as our own experience, particular with RxJS\footnote{\url{https://rxjs.dev/}}-based web applications, show that another review on this area may yield new insights.

Within this paper, we will work on the following two research questions:

\begin{itemize}
	\item \emph{RQ1: What challenges do frontend engineers face when debugging RxJS based code?}
	\item \emph{RQ2: How can the experience of frontend engineers during debugging of RxJS-based code be improved?}
\end{itemize}

Transcripts of informal interviews and ``war stories'' collected from multiple practitioners will give us insight in the challenges they face in their day-to-day jobs. We will evaluate and validate three scenarios extracted from their statements in order to answer \emph{RQ1}.

Later, we propose for \emph{RQ2} three solution concepts to resolve previously identified problems which ultimately should improve the debugging experience for RxJS-based code.

The implementation and validation of these proposals is then part of a third research question \emph{RQ3} and will be part of a future iteration on the topic:

\begin{itemize}
	\item \emph{RQ3: What is the impact of a proposed solution on the debugging experience of a frontend engineer?}
\end{itemize}

This introductory section will conclude with the clarification of important terms. Section~\ref{sec:interviews} presents the interview results along with the collected war stories and formalizes three recurrent challenges. With Section~\ref{sec:discussion}, we will have a look at current and previous research regarding debugging of reactive applications as well as specific tooling. We are going to validate presented challenges against currently available tools within Section~\ref{sec:study} and give an outlook on future iterations on this papers topic right after.

\subsection{Reactive Applications}

Salvaneschi et al. \cite{comprehendingReactiveApplications} define the ``Reactive Application'' \emph{(RA)} as a computer program which processes a continuos, indefinite and ever-changing flow of information. It is contrasted by a traditional application which consumes and processes one piece of input while producing a one-off output result: Think of an image format conversion program which takes an HEIF\footnote{\url{https://nokiatech.github.io/heif/technical.html}} image file for input, processes it and outputs an JPEG file likewise.

\begin{figure}[h]
	\centering
	\emph{TODO}

	\caption{Traditional vs. Reactive Application}
	\label{fig:reactive-application}
\end{figure}

Further Salvaneschi et al. provide a set of examples of what a reactive application might achieve with their three-parted classification schema: A \emph{synthetic application} transforms and processes streams of information. hence multiple image conversions one after another or in parallel could be implemented as a synthetic, reactive application. Beside the modelling of pure data flows, reactive applications are prevalent in the area of user interfaces \emph{(UI)}: They can be identified as \emph{interactive applications} and \emph{graphical animations} here.

Various ways of implementing reactive applications emerged over time. The Observer design pattern \cite{observerDesignPattern}, originated in Object Oriented Programming \emph{(OOP)}, is a basic pattern we can find in many of todays API implementations \cite{ownPaper}. Functional Programming \emph{(FP)} shines with specific reactive language extensions like Fran (Haskell) \cite{SurveyOnReactiveProgramming} or more recently REScala (Scala) \cite{10.1145/2577080.2577083}. The declarativeness of FP finally lead to what we understand under ``Reactive Programming'' today.

\subsection{Reactive Programming}

Reactive programming \emph{(RP)} is a declarative programming paradigm. Where engineers use imperative programing languages to tell a program every step \emph{how} to do something, a declarative language allows to describe \emph{what} wants to be achieved. The languages runtime system then figures out a way to satisfy that given description. RP specifically allows the description of a dependency graph of values and transformations over time.

\begin{figure}[h]
	\centering
	\emph{TODO}

	\caption{Reactive Programming Graph}
	\label{fig:reactive-programming}
\end{figure}

An RP environment provides (i) language constructs to describe mentioned graphs, often in form of a domain specific language \emph{(DSL)} \cite{REScala} \cite{otherRPDSL}. At program runtime, a (ii) runtime system takes care that changed values are propagated through the graph, transformations are recomputed where necessary and a consistent state is maintained.

\subsection{Debugging Concepts}

Debugging concepts can be divided roughly into three categories: Traditional \textbf{imperative-focused} debuggers provide basic functionality to interact with programs at runtime: Once the code execution is paused (i.e. using a breakpoint at a given statement), we gain access to the current call stack and the values assigned to variables of a given frame. Manual control of the programs execution allows to inspect the programs behavior step by step as well as assigning new values to variables ``on-the-fly''.

Where individual transformations of an RP based program can be inspected using a traditional debugger, they fall short in understanding the greater model of the dependency graph. In fact, RP provides its own challenges to debuggers. So are call stacks spoiled with the invocation of RP runtime system internal matter or breakpoints can only be used on the imperative parts of transformations rather than any given point in the dependency graph. Various \textbf{reactive} debuggers and visualization tools for different RP runtimes emerged over the past few years \cite{REDebuggerSalvaneschi} \cite{RxViz} \cite{RxFiddle} exploring this field. They have knowledge of the dependency graph and therefore allow improved interaction with RP concepts.

In matters of time, traditional as well as reactive debuggers work with the very present state of the programs execution only. They do not have any knowledge about what happened before or what is going to happen in the future. This shortcoming is tedious, especially when debugging a problem depending from multiple complex circumstances in a system. An \textbf{omniscient} debugger \cite{omniscientDebugger} does not interact with the executed program directly. Instead, it records runtime telemetry and provides an interface for later inspection. This way, engineers can ``time travel'' back and fore through program execution without the hassle of reconstructing a given failure situation. This concept comes with its own set of challenges, i.e. demands on storage capacity or user experience \emph{(UX)} design. \cite{omniscientDebuggerProblems}


\subsection{RxJS}

\begin{listing}[H]
	\begin{minted}{TypeScript}
		// Add Example
		const x: string = 'Hello World';
	\end{minted}
	\caption{Reactive Programming with RxJS}
	\label{lst:rp-with-rxjs}
\end{listing}

\section{Interviews and War Stories}
\label{sec:interviews}

\begin{itemize}
	\item We answer RQ1 here
	\item Present results of own informal interviews
	\item Combine with war stories
	\item Extract 3 main challenges
\end{itemize}

\section{Discussion}
\label{sec:discussion}

\begin{itemize}
	\item Closer look to past Research
	\item \dots and the tools which were built based on it
	\item Set up war story extract to be replicated with existing tooling
\end{itemize}

\begin{itemize}
	\item Brief overview on specific tooling
	\item For frontend, but also other tiers
	\item Rxviz \footnote{\url{https://rxviz.com/}} see also \url{https://rxviz.com/feedback} for input?
	\item rxjs-spy \footnote{\url{https://github.com/cartant/rxjs-spy}}
	\item rxfiddle \cite{10.1145/3180155.3180156}
	\item reactive-inspector \cite{10.1145/2884781.2884815}
	\item TOD \cite{5287015}
\end{itemize}


\section{Study Design}
\label{sec:study}

\begin{itemize}
	\item Use prev section to build experiments using existing tooling
	\item Validate stories and interviews
\end{itemize}

\section{Future Work}
\label{sec:future}

\begin{itemize}
	\item Pick up results from war stories and experiment
	\item Propose one solution per challenges
	\item Sketch how this could look like
	\item This answers RQ2
\end{itemize}

\section{Threats to Validity}
\label{sec:threats}

\begin{itemize}
	\item Informal interviews/war stories only
	\begin{itemize}
		\item Describe background of interview partners
		\item Frontend engineering heavy
	\end{itemize}
\end{itemize}

\section{Conclusion}
\label{sec:conclusion}

\begin{itemize}
	\item Recap Past Developments in RP Debugging
	\item Recap proposed solution
	\item Whats next in PA2?
	\item Whats the vision for the thesis?
\end{itemize}




\bibliographystyle{splncs04}
\bibliography{bibliography.bib}

\section*{License}
\ccby\thinspace\thinspace This work is licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.
\end{document}