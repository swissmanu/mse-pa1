\documentclass[12pt,a4paper]{article}
\usepackage{ccicons}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{booktabs}

\setminted{autogobble=true, tabsize=2, linenos=true, frame=single, breaklines=true}

\newcommand{\version}{v0.4 Draft}

\begin{document}
\begin{centering}

	\Large{Workshop Paper}
	\par
	\Huge{Debugging of RxJS-based Frontend Web Applications}
	\par
	\vspace{2ex}

	\normalsize{
		Manuel Alabor\\
		Supervised by Prof. Dr. Markus Stolze\\
		\par
		\vspace{2ex}
		HSR University of Applied Sciences Rapperswil, Switzerland\\
		\par
		\vspace{2ex}
		\today{} (\version)
	}
	\par
	\vspace{2ex}

	\begin{quotation}
		\small{
			\noindent\textbf{Abstract}---\input{./abstract.tex}
		}
		\par
		\vspace{4ex}
	\end{quotation}
\end{centering}

\section{Introduction}

An application providing a user interface (\emph{UI}) can be seen as a reactive application (\emph{RA})\cite{7827078}: It handles a continuos flow of user- and system-created events in order to give the user a representation of the applications state in a timely fashion. One way of implementing reactive behavior is the Observer design pattern\cite{gamma1995design}, where an observer (e.g. the UI rendering code) is repeatedly informed about changed application state. With Reactive Programming (\emph{RP}), another way to implement RAs is trending. RP is enabled by language extensions, runtime environments and domain-specific languages (\emph{DSL}) and based on functional programming (\emph{FP}) principles. With RP, software engineers describe declaratively how data flows through a RA, how that data depends from each other and how it is to be transformed over time.

Utilities to debug the runtime behavior of a program are essential to software engineers today. They help to understand the inner workings of unknown source code or allow to track down a problem which may lead to an unexpected failure in a particular situation. Debugging utilities took different forms over time: From interpreting memory dumps, manually adding print statements to trace program execution up to the point where specialized debugging programs can interrupt a running process and interact with it on a low level, software engineers have access to versatile debugging tools at the present day.

Debuggers available in IDEs and the developer tools of a web browser\footnote{\url{https://developer.mozilla.org/en-US/docs/Tools/Debugger}} today are specialized to work with imperative, control-flow oriented programs. E.g. when an engineer wants to know which part of the program called a particular function, the call stack gives a clear answer to this question. Assuming a dataflow oriented program implemented using RP, the question, which transformation was executed right before another cannot be answered using a call stack: A breakpoint within the transformation will not point to its logical predecessor, it will lead to the internals of the RP runtime instead.

This lack specific knowledge about RP concepts in traditional debugging utilities does often end in time-consuming debugging sessions as we can confirm from our own experience. Previous research has looked into this field \cite{10.1145/2577080.2577083} \cite{10.1145/2884781.2884815} \cite{10.1145/3180155.3180156} over the past years already. We will revisit their results in this paper and elaborate on the particular challenges of debugging RAs using RxJS for frontend web applications.

Transcripts of informal interviews and ``war stories'' collected from multiple practitioners will give insight in the challenges they face in their day-to-day jobs. We will validate their statements in an observational study and answer our first research question:

\begin{itemize}
	\item \emph{RQ1: What challenges do frontend engineers face when debugging RxJS-based code?}
\end{itemize}

In response to this, we will present concepts how to resolve previously identified problems and give an answer on the second research question:

\begin{itemize}
	\item \emph{RQ2: How can the experience of frontend engineers during debugging of RxJS-based code be improved?}
\end{itemize}

The future implementation and validation of these proposals leads to our third research question which will be part of future work not part of this paper:

\begin{itemize}
	\item \emph{RQ3: What is the impact of a proposed solution on the debugging experience of a frontend engineer?}
\end{itemize}

We will conclude this introductory section with the clarification of important terms. Section~\ref{sec:interviews} presents the interview results along with the collected war stories and formalizes two recurrent challenges. With Section~\ref{sec:discussion}, we will have a look at current and previous research regarding the debugging of RAs as well as specific tooling. We are going to validate presented challenges against currently available tools within Section~\ref{sec:study}, show threats to the validity of our work in Section~\ref{sec:threats} and finally end with an outlook on future iterations.

\subsection{Reactive Applications}

Salvaneschi et al. \cite{7827078} define a RA as a computer program which processes continuos, indefinite and ever-changing flows of data. Think of a spreadsheet application\cite{10.1145/2501654.2501666} that links the values of cells to other cells using formulas. Once a cell is changed, it is the task of the application to update all dependant cells accordingly and cascade the updates throughout the model. This dataflow based type of application is contrasted by program-flow based applications which consume and process one piece of input while producing a one-off output like an image format conversion program that transforms between HEIF\footnote{\url{https://nokiatech.github.io/heif/technical.html}} and JPEG image formats.

The classification schema by Salvaneschi et al. \cite{7827078} divides RAs into three types: A (i) \emph{synthetic application} transforms and processes streams of information. RAs are prevalent in the area of UIs further: They can be identified as (ii) \emph{interactive applications} and help to describe and implement (iii) \emph{graphical animations}.

\subsection{Reactive Programming}

Various ways of implementing RAs emerged over time. The Observer design pattern \cite{gamma1995design}, originated in Object Oriented Programming \emph{(OOP)}, is a pattern we can find in many of todays API implementations\cite{alabor:2019:reactiveappllications} allowing reactive behavior. Functional Programming \emph{(FP)} shines with specific reactive language extensions like Fran (Haskell) \cite{10.1145/2501654.2501666} or more recently REScala (Scala) \cite{10.1145/2577080.2577083}.

RP is a declarative programming paradigm. Where engineers use imperative programing languages to tell a program every step \emph{how} to do something, a declarative language allows to describe \emph{what} wants to be achieved. The language runtime system then figures out a way to satisfy that given description. RP environments specifically provide abstractions to describe a dataflow and dependency graph which is used to transform and direct data at runtime.

An RP environment provides (i) language constructs to describe mentioned graphs, often in the form of a DSL\cite{10.1145/2577080.2577083}. At program runtime, a (ii) runtime system takes care that changed values are propagated through the graph, transformations are recomputed where necessary and a consistent application state is maintained.

\subsection{Debugging Concepts}

We divide debugging concepts roughly into three categories: Traditional (i) \emph{imperative-focused debuggers} provide basic functionality to interact with programs at runtime: Once code execution is paused (i.e. using a breakpoint at a given statement), we gain access to the current call stack and the values assigned to variables of a given frame. Manual control of the program execution allows to inspect its behavior step by step as well as assigning new values to variables ``on-the-fly''.

Where individual transformations of an RP based program can be inspected using traditional debuggers, they fall short in understanding the underlying model of the dataflow graph. In fact, RP provides its own challenges to debuggers: Call stacks expose internal invocations of the RP runtime system rather than e.g. the predecessor transformation according to the dataflow graph. Further, breakpoints can only be used on the imperative parts of transformations and lack the functionality of interrupting execution when the RP runtime hits a specific node within the graph. A (ii) \emph{reactive debugger} has knowledge about the internal model of an RP runtime system. It leverages on it and provides specialized tools e.g. to navigate or visualize the dataflow graph \cite{10.1145/2884781.2884815} \cite{10.1145/3180155.3180156} \cite{rxviz}. We will have a closer look to available reactive debugger solutions.

The traditional as well as the reactive debugger works with the \emph{current} state of a program's execution only. They lack knowledge about what happened before or what is going to happen in the future. This shortcoming is tedious, especially when debugging a problem depending from multiple complex circumstances in a system. An (iii) \emph{omniscient debugger} \cite{5287015} \cite{DBLP:journals/corr/OCallahanJFHNP17} does not interact with the executed program directly. Instead, it records runtime telemetry and provides an interface for later inspection. Engineers can ``time travel'' back and forth through the program execution trace without the hassle of reconstructing a given failure situation over and over again. This concept comes with its own set of challenges though: Once decided \emph{what} information should be recorded (everything, only specific parts of the program, one thread, multiple threads, \dots), demands on storage performance and capacity increase while the pool of collected data grows. As a result, user experience (\emph{UX}) concepts need to be aligned for the engineers being able to interact with the sheer amount\cite{5287015} of information efficiently.

\subsection{ReactiveX and RxJS}

``Reactive Extensions'' (\emph{ReactiveX}) is an open-source project. Its members and contributors defined a generic description of an RP API. They further provide reference implementations of this API along with RP runtime environments for various programming languages like Java, C\# and JavaScript\footnote{\url{http://reactivex.io/languages.html}}. ReactiveX summarizes the API as ``\dots a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming''\cite{reactivex}. The core concept of the API specification is the Observable\footnote{There is no known relation between ReactiveX' concept of the Observable and the deprecated Java class \href{https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Observable.html}{\mintinline{TypeScript}{java.util.Observable}}.}: An Observable can be composed and linked (``piped'') with other Observables. It has the ability to push (``emit'') values to its dependents. Multiple depending Observables form and describe a dataflow graph eventually. A multitude of operators allow the transformation of values and (higher-order\footnote{An Observable emitted by another Observable is considered a Higher-Order Observable. This naming is related to the concept of higher-order functions in mathematics and computer science.}) Observables. Values emitted from an Observable can be subscribed to at any point which is closely related to the Observer design patterns \mintinline{Java}{attach} method.

RxJS is the reference implementation of the ReactiveX API specification for JavaScript and TypeScript. It is used thoroughly by large projects like Angular\cite{angualrrxjs}. Listing \ref{lst:rp-with-rxjs} shows an example of RP using RxJS in TypeScript.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		import { of } from 'rxjs';
		import { filter, map } from 'rxjs/operators';

		of('hello', 'foo', 'world').pipe(  // Create Observable
			filter(s => s !== 'foo'),        // filter Operator
			map(s => s.toUpperCase())        // map Operator
		).subscribe(console.log)           // Emits: HELLO, WORLD
	\end{minted}
	\caption{Basic RxJS Example}
	\label{lst:rp-with-rxjs}
\end{listing}

\section{Interviews and War Stories}
\label{sec:interviews}

We have worked together with 15 professional software engineers during the process of answering RQ1. On the way of finding our interview partners and war stories reporters, we noticed it to be a challenge on its own to find people which understand themselves as users of RP and related technologies. E.g. even though Angular makes heavy use of RxJS, we will see that many engineers do not interact with its abstractions directly in order to build simple UIs. In the end we were able to gather interesting statements nonetheless which we are going to present in this section.

\subsection{Informal Interviews}

We organized informal interviews which allowed us to gain first insight in how software engineers work with RP in their daily jobs. We talked to six engineers and asked them about the technologies they use, what their personal experience with RP was, what they most liked and most disliked about it.

Four of our interview partners stated to currently work or more recently have worked with RxJS in conjunction with Angular and/or ngrx\footnote{\url{https://ngrx.io/}} to develop frontend web applications. By being the creator of a visualizer for RxJS Observables, the fifth interviewee was a proficient RxJS user. Our sixth interview partner finally was a backend engineer which used akka-streams\footnote{\url{https://akka.io/}} in Scala to model data-flows for a WebSocket-based\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API}}, reactive API layer serving a web frontend application.

All of the interviewees referred to RP with overall positive experience. We heard statements like ``RP is a good way for composing multiple data sources'' and ``having a statically typed language combined with RP already guarantees some kind of basic correctness of my program'' repeatedly throughout all sessions. Hence a big strength of RP seems to be the ability to describe complex dataflow constructs using a specialized DSL. The learning curve can be steep for a novice engineer though: ``Being already challenged with new concepts of Angular and ngrx, I noticed RxJS concepts and operators to be hard to grasp in addition on top'' an interview partner giving lectures in frontend web application development stated further.

It was interesting to hear that, especially in the area of developing web applications using Angular, our partners seemed not to have to work with pure RxJS code often. E.g. when using ngrx for state management, ``the framework takes care that you do not have to interact with Observables on your own, but leverages greatly on their potential behind the scenes''. As soon as our interviewees had to extend built-in functionalities with their own features, e.g. a new effect\footnote{\url{https://ngrx.io/guide/effects}}, all of them valued the possibility to interact with underlying Observables highly.

When asked explicitly about what they dislike the most about RP, all interview partners with no exception emphasized the debugging process of an RP application as a big nuisance. The fact that our interviewees remembered the search for a bug as something negative did not surprise us, hence a bug is usually something negative afflicted. What did alarm us though was the fact that statements like ``In 99\% of all cases, I add console.log statements manually and run the program over and over again, trying to understand what is happening'' were prevalent and gave insight in \emph{why} our interview partners dislike RP debugging in particular. Multiple interviewees mentioned the Redux DevTools\footnote{\url{https://chrome.google.com/webstore/detail/redux-devtools}} as helpful when debugging Angular/ngrx applications nonetheless. Further, one single partner mentioned marble diagrams as very valuable in order to understand how an RxJS Observable works, no matter if during development or when debugging code. Marble diagrams are a way to visualize and describe the value-emitting behavior of an Observable over time. They are accepted throughout the ReactiveX community for documentation\cite{marblediagrams} and testing reasons\cite{marbletesting}.

\begin{figure}[H]
	\centering
	\input{figures/marble-diagram.pdf_tex}
	\caption{A Marble Diagram visualizing the Observable in Listing~\ref{lst:rxjs-debugging}. Each marble represents an emitted value. The vertical line at marble \mintinline{TypeScript}{6} indicates the Observable completed.}
	\label{fig:marble-diagram}
\end{figure}

\subsection{War Stories}

After we built a first intuition for how software engineers work with RP by evaluating the informal interviews, we were interested in more RxJS-specific, hands-on experiences. We asked the engineering community via Twitter\footnote{\url{https://twitter.com/swissmanu/status/1242429409208029185}} about their personal, most recent RxJS debugging war story and sent out various emails with the same request. After reaching out, we were able to collect five responses: One by an RxJS core team member, two from Angular Google Developer Experts and another two reports by two software engineers building web and mobile applications using React and RxJS which includes the author of this paper.

The reports provided us with diverse perspectives on various areas of software development using RxJS. One of the reporters focused on how they built code which had improved on testability over the recent versions of RxJS: ``[\dots] in the beginning, it was very hard to write async tests and I did not like it. I really disliked that once you started to test async code you were forced to pass a TestScheduler''. Allowing to pass the scheduler explicitly as parameter forced them to introduce code which was only necessary for testing reasons they stated further. With its current major version, RxJS 6 improved heavily on the  \mintinline{TypeScript}{TestScheduler}. The runtime environment itself can now be augmented with the scheduler which results in cleaner code.

Even though the share of non-productive, testing-related code necessary to build mature RxJS-based applications was mentioned to have decreased today, multiple of our reporters mentioned the common practice of manually modifying production code during debugging sessions, hence confirming earlier statements from our informal interview partners. One engineer described a specific scenario where they suspected a problem within a complex Observable composition: Having multiple asynchronous, remote data sources, they used Observables to model the dependencies between them and implemented computations on their results as operators. On top, each data source could re-emit updated versions of previously requested information any time. Though tested thoroughly, after a week in production the first of many bugs was reported: ``Figures were changing multiple times (where I expected them to change once), other numbers were not updated at all'' they told us. The browsers debugger tools and its breakpoints did not help much since the operators were executed several multiple times and some parts of the stream were impossible to grasp, even with conditional breakpoints. ``I started to inspect the flow [\dots] with console.logs and later also using tags from rxjs-spy which exposed more detailed life cycle information'', hence manually augmenting the code with trace logs. After the time-consuming log analysis, they finally were able resolve the bug. The log statements added were removed in the aftermath, though the rxjs-spy related code was left in the Observable stream in case they might be needed again in the future. (We will elaborate on the functionality of rxjs-spy in Section~\ref{sec:discussion} more in-depth.)

In a related war story, another engineer disclosed similar practices using  external tools: ``It took quite some time to get it right and one of the most invaluable tools proved to be Stackblitz which gave us ability to quickly create smaller working examples and iterate on them.'' Stackblitz\footnote{\url{https://stackblitz.com/}} is a full JavaScript development environment available online. They used this sandboxed setting to run, debug and iterate on selected pieces of a larger Observable stream. Even though the final result had to be integrated back into the actual application, the extra effort was worth the result the engineer concluded in their report.

A final story described yet another variation of the application of an external tool: Rather than using a dedicated sandbox to develop pieces of a more complex system, this engineer used Rx Visualizer, an online visualization utilities to generate previously presented marble diagrams from real code. Like in the report before, it was necessary to extracted code from the actual applications code base. But once done, the visualizations helped a lot in order to understand when values were emitted, when subscriptions changed and when Observables completed: ``Marble diagrams were a huge help to dig into detailed runtime and life cycle behaviors of the Observables.''.

\subsection{Wrap Up}

The overall sentiment in both the informal interviews as well as the reported war stories in regards of RP with RxJS was positive. The software engineers value how they can describe dataflows using a DSL, even though the learning curve was perceived as steep. We heard some interesting reports how RxJS is applied in a daily development environment: Marble diagrams help to understand  an Observables behavior and are useful to implement tests. Large frameworks like Angular hide some of the complexity of RxJS but allow engineers to make use of its full power once the provided functionality needs to be extended.

Most participants considered a statically typed language like TypeScript a fundamental necessity allowing them to implement dataflow graphs with minimal, formal correctness. We noticed throughout all reports that once the engineers were required to interact with the Observable graphs at runtime, they felt kind of ``lost'' and ``lacking the right tool'' to work within the context of RP though. Yet traditional debugging tools allowed them to inspect various parts of a stream, they were unable to get more information about e.g. life cycles of the Observable composition. Almost all of them referred to the practice of modifying their code manually and adding log statements where they assumed a problem. Listing~\ref{lst:rxjs-debugging} exemplifies challenges when debugging a stream of Observables with traditional debugging tools.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		interval(1000).pipe(    // Increasing numbers with 1s delay
		  map(i => i * 2),      // Breakpoint possible within i * 2
		  take(4),              // No breakpoint possible
		  tap(console.log)      // Manually added log statement
		).subscribe(showValue); // 0, 2, 4, 6
	\end{minted}
	\caption{Debugging of an RxJS Observable using breakpoints and log statements. \mintinline{TypeScript}{showValue} renders an emitted value to the UI.}
	\label{lst:rxjs-debugging}
\end{listing}

Where a breakpoint can easily be added to Line~2 within the arrow function, this is impossible for \mintinline{TypeScript}{take} on Line~3. One would need to place the breakpoint within the operators' internal implementation instead which can be cumbersome in case the operator is used in a different stream as well. Once the breakpoint on Line~2 interrupts the execution of the program, we will notice another shortcoming related to this circumstance: Rather than representing the logical flow implemented using the DSL, the call stack as shown in Listing~\ref{lst:rxjs-call-stack} points deep into RxJS' internal implementation.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		<anonymous> RxJS
			rxjs 6.5.2/internal/operators/map.js:49
			rxjs 6.5.2/internal/Subscriber.js:66
			rxjs 6.5.2/internal/observable/interval.js:23
			rxjs 6.5.2/internal/scheduler/AsyncAction.js:71
			// ...
	\end{minted}
	\caption{Call Stack for Arrow Function on Line~2 in Listing~\ref{lst:rxjs-debugging}}
	\label{lst:rxjs-call-stack}
\end{listing}

We further learned that log statements as shown on Line~4 in Listing~\ref{lst:rxjs-debugging} indeed help to trace emitted values, but do not expose any information about the life cycle of an Observable. The reporter describing their usage of rxjs-spy explained, that the knowledge about when an Observable gets subscribed, unsubscribed or completed helped a lot in order to solve problems related to higher-order Observables.

Finally, we understood that if a problem is hard to replicate within the actual application, the engineers use external sandbox development environments to isolate specific parts of an Observable composition. This allows them to iterate on it faster than it would be possible otherwise.

After the evaluation of all reports and interviews it is our speculation that software engineers are truly lacking debugging tools which ``understand'' RP concepts provided through RxJS. Even though traditional debuggers might help up to some extent, they do not provide all the information an engineer is interested in. The last resort in this situation is often the manual augmentation, modification and extraction of source code as we saw repeatedly. After a look at previous efforts in the area of reactive debugging, we are going to validate our assumption in Section~\ref{sec:study}.


\section{Discussion of Previous Efforts}
\label{sec:discussion}

Our work is not the first attempt to understand and improve on the struggles software engineers have to overcome when working on RP code, either with or without RxJS. We are going to present a selection of four utilities whereas two of them have an academic background. We either learned about them during our research because they were mentioned in one of the interviews and war stories or because we have worked with them personally in the past.

\subsection{Reactive Inspector}

Salvaneschi et al. did focus their research heavily on RP during the mid 2010s. Beside the creation of REScala in 2014 \cite{10.1145/2577080.2577083}, an RP DSL and runtime for the Scala programming language, they have looked into the debugging habits of software engineers as well. In the paper ``Debugging for Reactive Programming'' \cite{10.1145/2884781.2884815}, Salvaneschi et al. elaborate on the necessity of RP debugging tools which can understand the specific language abstractions. With \emph{Reactive Inspector} plugin for the Eclipse IDE, they provide a debugger which understands the RP language abstractions of REScala. One of its main features is the visualization of the internal dependency graph. The new class of  breakpoints, the ``reactive breakpoints'', builds upon the visualized graph as well: They do not depend on a specific line of code or statement rather then on a specific node in the graph. The execution of the program can be interrupted e.g. once a node retains a specific output value or an event of interest takes place in the runtime. Along with the RP specific debugging features, Reactive Inspector implements omniscient debugging concepts as well: Time travel allows to record and replay runtime behavior at a later time without re-execution.

Salvaneschi et al. claim\cite{10.1145/2577080.2577083} the architecture behind \emph{Reactive Inspector} to be flexible enough to be used with different RP runtime environment as well.

\subsection{rxfiddle}

\emph{rxfiddle} as proposed by Banken et al. is the first reference implementation of their RP debugger architecture for the ReactiveX API specification described in their paper ``Debugging Data Flows in Reactive Programs'' \cite{10.1145/3180155.3180156}. The design defines two independent parts: The (i) \emph{Host instrumentation} instruments a ReactiveX implementation to emit events at runtime (e.g. when an Observable is created or subscribed) which get collected. The (ii) \emph{Visualizer} component interprets these events and presents them along two dimensions: The StoryFlow graph \cite{YWu2013a} shows when an Observable is created and how it interacts with other Observables. An additional marble diagram for every Observable is used to display the values it emits over time.

The reference implementation supports event collection for RxJS-based code in versions 4 and 5. It can either be used on a local development machine on existing projects or by copying code snippets to the online available.

The architectural design of \emph{rxfiddle} is similar to the one \emph{Reactive Inspector}: Banken et al. provide a system where different RP runtime environments should be able to be attached to the Visualizer easily.

\subsection{rxjs-spy}

Software engineers tend to augment their code with additional log trace statements in the situation where they have to track down a problem as we saw earlier. rxjs-spy\cite{rxjsspy} intends to improve on this by introducing the \mintinline{TypeScript}{tag} operator along with sophisticated log monitoring facilities. Ideally, ``tagged'' Observables are created during development when the data-flows are composed for the first time. Like the \mintinline{TypeScript}{tap} operator, a tag as shown in Listing~\ref{lst:rxjs-spy-tag} on Line~3 does not influence runtime behavior of an application.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		interval(1000).pipe(
		  map(i => i * 2),
		  tag('multiply'),
		  map(i => i - 1),
		  take(2)
		).subscribe();
	\end{minted}
	\caption{Usage of \emph{rxjs-spy} \mintinline{TypeScript}{tag} Operator on Line~3}
	\label{lst:rxjs-spy-tag}
\end{listing}

Once necessary, rxjs-spy can be advised to log events such as subscribe, emit, error, complete and unsubscribe of matching tags directly to the console without touching any Observable code at all. The additional events logged by rxjs-spy were noted invaluable in the interviews presented earlier as well as in our own experience.

\begin{listing}[H]
	\begin{minted}{Typescript}
		Tag = multiply; notification = subscribe
		Tag = multiply; notification = next; value = 0
		Tag = multiply; notification = next; value = 2
		Tag = multiply; notification = unsubscribe
	\end{minted}
	\caption{Trace log generated by \emph{rxjs-spy} \mintinline{TypeScript}{tag} from Listing~\ref{lst:rxjs-spy-tag}}
	\label{lst:rxjs-spy-log}
\end{listing}

Additional features are available through the debuggers console interface. A tagged Observable can be paused so it collects incoming values. They can then be emitted one after another or resumed at once.

\subsection{Rx Visualizer}

The \emph{Rx Visualizer}\cite{rxviz} is a utility available online in the browser. It is an ``animated playground for Rx Observables''\cite{rxviz} and allows to visualize snippets of RxJS code using marble diagrams. Diagrams are generated over a given, fixed time and can be saved as SVG\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/SVG}}.

The visualizer helps to understand the behavior of a specific part of an Observable stream in a sandboxed environment as a reported war story stated.

\subsection{Comparison}

Specialized utilities are aware of RP runtime environments and help software engineers to interpret its state better than before using sole traditional debugger tools. Most of them provide a way to represent the dataflow graph either graphically (Reactive Inspector, rxfiddle) or in textual form (rxjs-spy). They visualize the data flowing through the graph over time in marble diagrams (rxfiddle, Rx Visualizer) or directly in a visual graph representation (Reactive Inspector). Some like Reactive Inspector for REScala provide an ``all in one'' solution with breakpoints, omniscient debugging capabilities and full IDE integration whereas the RxJS-related tools provide small, differentiated feature sets. Most of them require the engineer to extract code from its origin (rxfiddle, Rx Visualizer) or require manual code preparation or modification (rxjs-spy).

\begin{table}[H]
	\begin{tabular}{@{}lllll@{}}
	\toprule
					   & \textbf{UI} & \textbf{Integration}                                               & \textbf{Flow Control}                                              & \textbf{RP Runtime} \\ \midrule
	Reactive Inspector & Visual      & Eclipse IDE                                                        & Full                                                               & REScala             \\ \midrule
	rxfiddle           & Visual      & Web App                                                            & None       & RxJS                \\ \midrule
	rxjs-spy           & Textual     & \begin{tabular}[c]{@{}l@{}}Browser Console\\and Code\end{tabular} & Limited & RxJS                \\ \midrule
	Rx Visualizer      & Visual      & Web App                                                            & None       & RxJS                \\ \bottomrule
	\end{tabular}
	\caption{Feature Matrix for Discussed RP Debugging Tools}
	\label{tab:compare-tools}
\end{table}

\section{Validation of Interviews and War Stories}
\label{sec:study}

We explored on how engineers use RP and what techniques they might apply for debugging problems earlier. We observed that most participants tend to modify their source code manually with trace logs and alike in order to find underlying problems. It is further our own experience that this practice is often not a productive one since the evaluation of trace information, once available, can be cumbersome and time-consuming. In addition, removing log statements after the debugging process might leave new bugs in production code if not done carefully. We identified this circumstance as one of the main debugging practices when software engineers work with RxJS-based code.

This is why we saw the need in validating earlier statements about manual code modification for debugging reasons with an observational study. Our study sought to validate the following hypothesis:

\begin{itemize}
	\item \emph{Hypothesis: If software engineers are given an RxJS-based problem, then they will modify the code in order to understand its behavior.}
\end{itemize}

\subsection{Study Design}

The subjects for our study were required to have experience in developing applications with RxJS. We did not distinguish between frontend or backend engineers, hence in the end were able to find four subjects willing to participate in our experiment. We were interested to see how the subjects apply debugging techniques they would use in a common situation at their jobs. This is why we decided to conduct the experiment in a rather uncontrolled environment where the subjects used their own devices with their development environments of personal preference. Our objective for the experiment was communicated as broad as possible to prevent bias: ``We are interested in how \emph{you} debug a problem'' did not mention the hypothesis by intention.

We planned to have a one-hour session for the actual experiment with each subject, followed-up by an unattended quantitative after-action survey. The experiment was executed in two consecutive blocks of 25 minutes each. We provided a ZIP file containing the source code for two frontend web applications implemented using TypeScript and RxJS along with a test suite at the start of the experiment. Each of these applications were rigged with two to three bugs which we asked the subjects to identify and fix using whatever debugging techniques they prefer and commonly use. A block was considered as complete once either the test suite signaled all bugs as resolved or the 25 minutes were exceeded. We asked our subjects to act like in a pair programming situation where they ``think out loud'' their thought process. We refrained to answer any question related to the ``where'' a bug has to be expected though.

A week before the actual experiment, we sent out the participant briefing document to all of our subjects. We outlined the course of action and provided them with an example ZIP file. This file contained the same setup as the file provided at the experiment and allowed the subjects to get accustomed with things like starting the web applications or running the test suites.

We decided to monitor our subjects' progress remotely using voice chat and screen sharing due to the COVID-19 situation at the time of our study. This allowed us further to record the sessions with relative low technical effort for later evaluation.

The after-action survey was provided within 24 hours after a subject's participation in the main part of the study. We asked the subjects about (i) the number of years they have experience with RxJS, (ii) if they currently use RxJS on or off their jobs, (iii) in which field (like frontend, backend or others) they use RxJS and finally (iv) which tools and techniques they use to debug RxJS-based code. The respective answers allowed us to put the observed actions into perspective and detect potential irregularities in case a subject acted differently as they would have in a ``real'' situation.

\subsection{Results}

After the subjects got a feel for what the application on front of them should do, all of them used the provided test suite to check what features do not work as expected and tried to recreate the failing behavior in the UI manually. Two of them used the traditional debugging tools provided by their browser or IDE to step through parts of the code trying to understand what triggered the failing tests.

For both problems given, all subjects could be observed to make use of manually added trace log statements which they either added to existing arrow functions and/or using the \mintinline{TypeScript}{tap} operator. Neither did any of them use additional external tools where they put parts of the code for further inspection nor did they install additional debugging libraries like rxjs-spy.
After the 25 minutes of the second block exceeded, one subject noted that they would have usually started now to decompose the problem into smaller pieces and observe their behavior more isolated.

The responses on the survey showed that 75\% of the subject population had two or more years of experience with RxJS. Where all of them use RxJS to develop frontend applications, one subject declared having RxJS used for backend development as well. When asked what tools they usually use for debugging, only one subject told not to use the traditional debugger of their browser and/or IDE. Two of them leverage additional tracing functionality of rxjs-spy and all of them use manual log statements.

\subsection{Interpretation}

We were able to observe how all subjects modified the provided source code manually and augmented it with trace logs at some point. All of them used the produced information in order to track down problems in the application. The extraction to and reintegration from an external tool was not observed, though would have been yet another form of code modification.

For any subject, we could not identify any contradiction between the observed behavior and the answers given within the after-action survey.

All reviewed subjects exhibited the debugging behavior described in our initial hypothesis which we can accept based on the collected evidence.

Talking to professionals during the informal reviews, evaluating the war stories as well as the hands-on experiences and results from the observational study allowed us to identify three main challenges software engineers have to overcome when working with RxJS within an application, hence answering RQ1: (i) They want to \emph{understand how and what data flows} through the graph described by the RP DSL. This helps to identify simpler problems most of the time, though knowing about the life cycle events of Observables was noted as crucial especially when working with more complex, higher-order compositions of Observables. (ii) Where traditional debugging tools provide support suited for an imperative programming style, they fall short when interacting with RP-based code which would require a \emph{deeper understanding of the RP runtimes internal graph-based model}. This makes it hard for engineers to retrace dataflows and computations. And finally, (iii) even though there are partial solutions available to the two previous described challenges, they usually require the software engineers either to \emph{manually modify source code or extracting parts of it} to an external utility. These additional efforts cost time and bring their own risks since the production code needs to be touched without adding actual value.

\section{Future Work}
\label{sec:future}

Having the main challenges for engineers identified when debugging RxJS-code, we can propose areas to improve on now and resolve RQ2 by doing so.

\subsection{Improve User Experience}

Our overall goal is to support engineers during the process of understanding the inner workings of RxJS data-flow graph. Existing tools and libraries provide some help, though often struggle by means of the UX: Trace logs with relevant information like life cycle events do improve the debugging process as we saw. Digging through hundreds of log entries containing information of multiple Observables gets tedious quickly though. Filter and search functionalities help, but do not resolve all UX challenges here.

Visualizing the data-flow graph work better to show dependencies within the model compared to textual trace logs. Previous research showed that the sheer amount of nodes in a complex graph is hard to visualize effectively \cite{10.1145/3180155.3180156} on one side, on the other not as easy to implement efficiently since the mass of collected data grows quickly. Storing a representation of the graph rarely enough since engineers are interested in the values emitted over time per node as well.

We intend to find a solution that combines the power of textual trace logs with the ease-of-use of a graphical visualization for RxJS data-flow graphs.

\subsection{Automatic Code Augmentation}

RP code needs to be augmented with additional functionality so telemetry data can be collected. This happens using code weaving\cite{10.1145/2884781.2884815} or similar techniques\cite{10.1145/3180155.3180156} but especially in the area of RxJS often manually. We want to make the manual modification of production source code obsolete. rxfiddle proofed such mechanisms to work with RxJS 4 and 5, hence we intend to bring this feature to version 6, and possibly the upcoming major version 7 as well.

\subsection{Integration}

75\% of our observational study's participants used the debugging tools integrated to their browser and/or IDE. Even though some of them stated to know additional external utilities in the after-action survey, none of them went that far and used them during the one-hour session.

We understand the observed behavior as evidence for a hurdle preventing engineers from using specialized RP debugging utilities. In order to reach more software engineers with RP domain-specific debugging tools, we want to provide a potential solution as tightly integrated with the developer tools of the browser and or an IDE.

\subsection{Other Areas of Improvement}

There are many more areas which could be worth a further look in the future. E.g. the combination of controlling the programs execution based on breakpoints within the data-flow graph or concepts of omniscient debugging are interesting fields as well. We will focus on the previous three topics for our own future work but keep other ideas in a backlog in case time allows additional iterations on them.

\section{Threats to Validity}
\label{sec:threats}

\begin{itemize}
	\item Informal interviews/war stories only
	\begin{itemize}
		\item Describe background of interview partners
		\item Only 4 Participants in experiment
		\item Code in experiment carefully crafted... Though is it representative?
		\
	\end{itemize}
\end{itemize}


\begin{itemize}
	\item Pick up results from war stories and experiment
	\item Propose one solution per challenges
	\item Sketch how this could look like
	\item This answers RQ2
\end{itemize}

\section{Conclusion}
\label{sec:conclusion}

\begin{itemize}
	\item Recap Past Developments in RP Debugging
	\item Recap proposed solution
	\item Whats next in PA2?
	\item Whats the vision for the thesis?
\end{itemize}


\bibliographystyle{splncs04}
\bibliography{bibliography.bib}

\section*{License}
\ccby\thinspace\thinspace This work is licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.
\end{document}