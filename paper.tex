\documentclass[12pt,a4paper]{article}
\usepackage{ccicons}
\usepackage{hyperref}
\usepackage{minted}

\setminted{autogobble=true, tabsize=2, linenos=true, frame=single, breaklines=true}

\newcommand{\version}{v0.3 Draft}

\begin{document}
\begin{centering}

	\Large{Workshop Paper}
	\par
	\Huge{Debugging of Modern RxJS-based Frontend Web Applications}
	\par
	\vspace{2ex}

	\normalsize{
		Manuel Alabor\\
		Supervised by Prof. Dr. Markus Stolze\\
		\par
		\vspace{2ex}
		HSR University of Applied Sciences Rapperswil\\
		\par
		\vspace{2ex}
		\today{} (\version)
	}
	\par
	\vspace{2ex}

	\begin{quotation}
		\small{
			\noindent\textbf{Abstract}---\input{./abstract.tex}
		}
		\par
		\vspace{4ex}
	\end{quotation}
\end{centering}

\section{Introduction}

An application providing a user interface (\emph{UI}) is a reactive application (\emph{RA}): It handles continuos flow of user and system events in order to give the user a representation of the applications state as timely as possible. One way of implementing reactive behavior is the Observer design pattern \cite{gamma1995design} where an observer (e.g. the UI rendering code) is repeatedly informed about changed application state. Different ways to implement a RA were developed since the emergence of the Observer pattern as well. Reactive Programming (\emph{RP}) enabled through language extensions, runtime environemnts and domain specific languages (\emph{DSL}) is based on functional programming (\emph{FP}) principles and allows to describe dependencies and transformations within a RA declerativly.

Debugging tools are essential to software engineers in order to get deeper understanding of the runtime behavior of a software system. Engineers use them to understand why particular circumstances lead to unexpected failures during execution or to step through unknown source code getting themselves accustomed with it. IDEs as well as the developer tools of modern web browsers\footnote{\url{https://developer.mozilla.org/en-US/docs/Tools/Debugger}} provide battle-tested debugger utilities to inspect code. They let engineers step from program statement to statement, stop execution upon hitting a breakpoint and give insight on the values assigned to variables.

Todays debugging tools can not understand abstractions introduced by RP libraries. E.g. where the engineer can use the stack trace to track a problem to its root cause in a traditional imperative program, this does not work when an RP environment is used: The debugger does not have any knowledge of the underlying data flow graph which would allow a similar backtracking from graph node to node.

We will elaborate on such challenges in the field of RxJS-based frontend web applications and search answers to the following two research questions:

\begin{itemize}
	\item \emph{RQ1: What challenges do frontend engineers face when debugging RxJS based code?}
	\item \emph{RQ2: How can the experience of frontend engineers during debugging of RxJS-based code be improved?}
\end{itemize}

Transcripts of informal interviews and ``war stories'' collected from multiple practitioners will give us insight in the challenges they face in their day-to-day jobs. We will evaluate and validate three cases extracted from their statements in order to answer \emph{RQ1}.

Later, we propose three solution concepts for \emph{RQ2} to resolve previously identified problems which ultimately should improve the debugging experience for RxJS-based code.

The future implementation and validation of these proposals leads to a third research question \emph{RQ3} which will be part of future work not part of this paper:

\begin{itemize}
	\item \emph{RQ3: What is the impact of a proposed solution on the debugging experience of a frontend engineer?}
\end{itemize}

We will conclude this introductory section with the clarification of important terms. Section~\ref{sec:interviews} presents the interview results along with the collected war stories and formalizes two recurrent challenges. With Section~\ref{sec:discussion}, we will have a look at current and previous research regarding debugging of reactive applications as well as specific tooling. We are going to validate presented challenges against currently available tools within Section~\ref{sec:study}, show threats to validity of our work in Section~\ref{sec:threats} and finally end with an outlook on future iterations.

\subsection{Reactive Applications}

Salvaneschi et al. \cite{7827078} define the RA as a computer program which processes a continuos, indefinite and ever-changing flow of information. It is contrasted by a traditional application which consumes and processes one piece of input while producing a one-off output result: Think of an image format conversion program which takes an HEIF\footnote{\url{https://nokiatech.github.io/heif/technical.html}} image file for input, processes it and outputs an JPEG file likewise.

Further, Salvaneschi et al. provide a set of examples of what a RA might achieve using a three-parted classification schema: A \emph{synthetic application} transforms and processes streams of information. hence multiple image conversions one after another or in parallel could be implemented as a synthetic, RA. Beside the modelling of pure data flows, RAs are prevalent in the area of user interfaces \emph{(UI)}: They can be identified as \emph{interactive applications} and \emph{graphical animations} here.

Various ways of implementing RAs emerged over time. The Observer design pattern \cite{gamma1995design}, originated in Object Oriented Programming \emph{(OOP)}, is a basic pattern we can find in many of todays API implementations \cite{alabor:2019:reactiveappllications}. Functional Programming \emph{(FP)} shines with specific reactive language extensions like Fran (Haskell) \cite{10.1145/2501654.2501666} or more recently REScala (Scala) \cite{10.1145/2577080.2577083}. The declarativeness of FP finally lead to what we understand under ``Reactive Programming'' today.

\subsection{Reactive Programming}

Reactive programming \emph{(RP)} is a declarative programming paradigm. Where engineers use imperative programing languages to tell a program every step \emph{how} to do something, a declarative language allows to describe \emph{what} wants to be achieved. The languages runtime system then figures out a way to satisfy that given description. RP specifically allows the description of a dependency graph of values and transformations over time.

An RP environment provides (i) language constructs to describe mentioned graphs, often in form of a DSL\cite{10.1145/2577080.2577083}. At program runtime, a (ii) runtime system takes care that changed values are propagated through the graph, transformations are recomputed where necessary and a consistent state is maintained.

\subsection{Debugging Concepts}

We divide debugging concepts roughly into three categories: Traditional \textbf{imperative-focused debuggers} provide basic functionality to interact with programs at runtime: Once code execution is paused (i.e. using a breakpoint at a given statement), we gain access to the current call stack and the values assigned to variables of a given frame. Manual control of the programs execution allows to inspect the programs behavior step by step as well as assigning new values to variables ``on-the-fly''.

Where individual transformations of an RP based program can be inspected using traditional debuggers, they fall short in understanding the greater model of the dependency graph. In fact, RP provides its own challenges to debuggers: So are call stacks spoiled with invocations of RP runtime system internal matter or breakpoints can only be used on the imperative parts of transformations rather than on the data flow within the graph. Various \textbf{reactive debuggers} and visualization tools for specific RP runtimes emerged over the past few years \cite{10.1145/2884781.2884815} \cite{10.1145/3180155.3180156} \cite{rxviz} exploring this field. They have knowledge of the dependency graph and therefore allow improved interaction with RP concepts.

Traditional as well as a reactive debuggers work with the very current state of the programs execution only. They lack knowledge about what happened before or what is going to happen in the future. This shortcoming is tedious, especially when debugging a problem depending from multiple complex circumstances in a system. An \textbf{omniscient debugger} \cite{5287015} \cite{DBLP:journals/corr/OCallahanJFHNP17} does not interact with the executed program directly. Instead, it records runtime telemetry and provides an interface for later inspection. Engineers can ``time travel'' back and fore through the program execution trace without the hassle of reconstructing a given failure situation over and over again. This concept comes with its own set of challenges though: Once decided \emph{what} information should be recorded (everything, only specific parts of the program, one thread, multiple threads, \dots), demands on storage performance and capacity increase while the pool of collected data grows. As a result, user experience (\emph{UX}) concepts need to be aligned for the engineers being able to interact with the sheer amount of information efficiently.

\subsection{ReactiveX and RxJS}

Reactive Extensions is an open source project providing an API description for RP concepts. It describes itself as ``\dots a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming'' \cite{reactivex}.  The API specification introduces the concept of the  \mintinline{TypeScript}{Observable} at its core. An \mintinline{TypeScript}{Observable} has the ability to be composed with other \mintinline{TypeScript}{Observable}s and eventually describe the dependency graph known in RP. A multitude of operators allow the transformation of values and \mintinline{TypeScript}{Observable}s within the graph.

The ReactiveX community works on a variety of reference implementations\footnote{\url{http://reactivex.io/languages.html}}: Libraries for Java, C\#, JavaScript and many more allow to work with similar API semantics on different software architecture levels.

RxJS is the reference implementation for JavaScript. Its current major version 6 is completely done in TypeScript\footnote{\url{https://www.typescriptlang.org/}} and provides the core elements of the ReactiveX API specification. Large projects like Angular embed and use RxJS\cite{angualrrxjs}. The Listing \ref{lst:rp-with-rxjs} shows a short example of RP using RxJS.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		of('hello', 'foo', 'world').pipe(
			filter(s => s !== 'foo'),
			map(s => s.toUpperCase())
		).subscribe(console.log)             // HELLO, WORLD
	\end{minted}
	\caption{RxJS Code Example}
	\label{lst:rp-with-rxjs}
\end{listing}

\section{Interviews and War Stories}
\label{sec:interviews}

\subsection{Informal Interviews}

In order to prepare to give an answer on the first research question, we started with a series of informal interviews. We talked to professionals about their experience in working with RP in their daily jobs. We did not limit the selection of our interview partners by the tech stack of including RxJS since we were interested in as many different perspectives on the topic as possible in this early stage. Eventually, we interviewed six engineers: Four work or worked more recently with Angular\footnote{\url{https://angular.io/}} and ngrx\footnote{\url{https://ngrx.io/}} to develop frontend applications. Two of them stated to have more explicit experience with RxJS further. One subject works currently with a combination of akka\footnote{\url{https://akka.io/}} and akka-streams in Scala to create backend applications. The sixth subject was the creator of rxfiddle. The agenda available in Appendix~\ref{sec:interviewquestions} was used to maintain focus during the interview sessions.

We identified several recurring topics throughout all the interviews. All of the subjects noted that they think of RP as an invaluable tool to describe and model dependencies between multiple data sources. Most of them appreciate how RP allows them to implement data transformations in a concise and composable way. The complexity of concurrent programming can be hidden well behind a simple DSL one subject noted further.

For the implementation, all subjects noted that a language with a strong type system is to be preferred: The compiler gives the guarantee of basic code correctness which is why e.g. TypeScript is used by all the subjects working with RxJS and Angular.

None of the subjects remembered debugging RP code to be a positive experience, independent of the technology used. All of the subjects use traditional debugging tools. Redux\footnote{\url{https://redux.js.org/}} DevTools \footnote{\url{https://github.com/reduxjs/redux-devtools}} is in use by all four subjects working with ngrx. There was no mention of any more specific debugging tool in regards of akka and akka-streams.

One particular subject with more in-depth knowledge on RxJS described situations where they would have wished for tools which could ``understand'' the actual \mintinline{TypeScript}{Observable} graph better: (i) When an error is thrown within the function passed to an operator, the generated stack trace reflects where the operator called the function rather than the actual location where the function is implemented. (ii) In order to understand how data traverses through the graph, subjects augmented code manually with the \mintinline{TypeScript}{tap}\footnote{\url{https://rxjs.dev/api/operators/tap}} side effect operator to log values. A less manually invasive way would be preferable as stated.

\subsection{War Stories}

Based on the results of the interviews, we compiled a request for more specific factual reports. We asked professional software engineers about their most recent debugging experience in regards of RxJS, either good or bad. We were able to gather responses from one RxJS core team member, two Google Developer Experts and two engineers building web and mobile applications for a fintech company eventually.

We could verify previously gathered interview data with the results from the new reports: The subjects tend to manually add log statements to their code in order to understand its behavior, especially when things get more complex. Three subjects even claimed using specialized logging functionalities provided by rxjs-spy\cite{rxjsspy}. As the subjects stated, the knowledge about additional events made visible helped in situations where they needed to find problems within a graph composing multiple asynchronous data sources on multiple levels. Without it, they would have been blind to what actually happened within the system.

In addition to more sophisticated logging, three subjects reported that they built a habit of decomposing complex graphs into smaller, simpler bits and running those in a dedicated environment like Rx Visualizer\cite{rxviz} or StackBlitz\footnote{\url{https://stackblitz.com/}}.

\subsection{Summary}

The interpretation of the combined interview and war stories data gives us an idea about two main challenges software engineers have to overcome during debugging activities of RxJS-based code:

It is crucial to the engineers to \textbf{understand data flows}  within the \mintinline{TypeScript}{Observable} graph. Questions like ``Which source emitted a value at what time?'' or ``What is the result of a specific transformation?'' are common in this context. Once a program fails, software engineers need to \textbf{rely on traditional debugger tools}. Though providing help to some extent, the tools lack of specific knowledge about the RP runtime environment adds some oddities to the debugging process: The (i) functionalities allowing step-wise navigation through the code does not respect the RP context. Assume we have set a breakpoint at \mintinline{TypeScript}{i * 2} on line~2 of Listing~\ref{lst:rxjs-step-controls}. Once the debugger hits the breakpoint and we instruct it to ``Step Over'', the debugger will lead us to the internal implementation of the \mintinline{TypeScript}{map} operator instead to line~3. (ii) Stack traces include information about the invocation of internal functions which, most of the time, do not provide any valuable information to the engineers further.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		interval(1000).pipe(      // Increasing numbers with 1s delay
		  map(i => i * 2),        // Breakpoint on i * 2
		  map(i => i - 1),
		  take(2)
		).subscribe(console.log); // -1, 1
	\end{minted}
	\caption{Example RxJS Stream With Breakpoint on Line 2 Within the Arrow Function}
	\label{lst:rxjs-step-controls}
\end{listing}


\section{Discussion of Previous Efforts}
\label{sec:discussion}

Our work is not the first approach on understanding and improving on the struggles software engineers have to overcome when working on RP code, either with or without RxJS. We are going to present four of this tools in this section. This list is not meant to be exhaustive. It contains tools we either got to know during our research because they were mentioned in one of the interviews or we worked with them personally in the past.

\subsection{Reactive Inspector}

Salvaneschi et al. did focus their research heavily on RP during the mid 2010s. Beside the creation of REScala in 2014 \cite{10.1145/2577080.2577083}, an RP DSL and runtime for the Scala programming language, they looked into the debugging habits of software engineers as well. In the paper ``Debugging for Reactive Programming'' \cite{10.1145/2884781.2884815}, Salvaneschi et al. elaborate on the necessity of RP debugging tools which can understand the specific language abstractions. With the plugin Reactive Inspector for the Eclipse IDE, they provide a debugger which understands the RP language abstractions of REScala. One of its main features is the visualization of the internal dependency graph. The new class of  breakpoints, the ``reactive breakpoints'', builds upon the visualized graph as well: They do not depend on a specific line of code or statement rather then on a specific node in the graph. The execution of the program can be interrupted e.g. once a node retains a specific output value or an event of interest takes place in the runtime. Along with the RP specific debugging features, Reactive Inspector implements omniscient debugging concepts as well: Time travel allows to record and replay runtime behavior at a later time without reexecution.

Salvaneschi et al. claim\cite{10.1145/2577080.2577083} the architecture behind \emph{Reactive Inspector} to be flexible enough to be used with different RP runtime environment as well.

\subsection{rxfiddle}

rxfiddle proposed by Banken et al. is the first reference implementation of their RP debugger architecture for the ReactiveX API specification described in their paper ``Debugging Data Flows in Reactive Programs'' \cite{10.1145/3180155.3180156}. The design defines two independent parts: The (i) \emph{Host instrumentation} instruments a ReactiveX implementation to emit events at runtime (e.g. when an \mintinline{TypeScript}{Observable} is created or subscribed) which get collected. The (ii) \emph{Visualizer} component interprets these events and presents them along two dimensions: The StoryFlow graph \cite{YWu2013a} shows when an \mintinline{TypeScript}{Observable} is created and how it interacts with other \mintinline{TypeScript}{Observable}s. An additional marble diagram\footnote{Marble diagrams are used in the ReactiveX community to describe the behavior of an \mintinline{TypeScript}{Observable} over its life time. They are considered valuable for documentation \cite{marblediagrams} as well as for testing \cite{marbletesting}} for every \mintinline{TypeScript}{Observable} is used to display the values it emits over time.

The reference implementation supports event collection for RxJS-based code in version 4 and 5. It can either be used on a local development machine on existing projects or by copying code snippets to the online available.

The architectural design of \emph{rxfiddle} is similar to the one \emph{Reactive Inspector}: Banken et al. provide a system where different RP runtime environments should be able to be attached to the Visualizer easily.


\subsection{rxjs-spy}

Software engineers tend to augment their code with additional log trace statements in the situation where they have to track down a problem as we saw earlier. rxjs-spy\cite{rxjsspy} intends to improve on this by introducing the \mintinline{TypeScript}{tag} operator. Instead of adding log traces at debug-time, ``tagged'' \mintinline{TypeScript}{Observable}s are created right at the moment the \mintinline{TypeScript}{Observable} itself is defined. A tag as shown in Listing~\ref{lst:rxjs-spy-tag} does not influence runtime behavior at first.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		interval(1000).pipe(
		  map(i => i * 2),
		  tag('multiply'),
		  map(i => i - 1),
		  take(2)
		).subscribe();
	\end{minted}
	\caption{Usage of \emph{rxjs-spy} \mintinline{TypeScript}{tag} Operator on Line 3}
	\label{lst:rxjs-spy-tag}
\end{listing}

Later, rxjs-spy can be advised to log events such as subscribe, emit, error, complete and unsubscribe of matching tags directly to the console without touching any \mintinline{TypeScript}{Observable} code at all. It is worth to mention that manual log traces, without additional effort, only show values flowing by. The additional events logged by rxjs-spy were noted invaluable in the interviews presented earlier as well as in our own experience.

\begin{listing}[H]
	\begin{minted}{Typescript}
		Tag = multiply; notification = subscribe
		Tag = multiply; notification = next; value = 0
		Tag = multiply; notification = next; value = 2
		Tag = multiply; notification = unsubscribe
	\end{minted}
	\caption{Trace log generated by \emph{rxjs-spy} \mintinline{TypeScript}{tag} from Listing~\ref{lst:rxjs-spy-tag}}
	\label{lst:rxjs-spy-log}
\end{listing}

Additional features are available through the debuggers console interface. A tagged \mintinline{TypeScript}{Observable} can be paused so it collects incoming values. They can then be emitted one after another or resumed at once.

\subsection{Rx Visualizer}

The \emph{Rx Visualizer}\cite{rxviz} is a utility available online in the browser. It is an ``animated playground for Rx Observables''\cite{rxviz} and allows to visualize snippets of RxJS code using marble diagrams. Diagrams are generated over a given, fixed time and can be saved as SVG\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/SVG}}.

The visualizer helps to understand the behavior of a specific part of an \mintinline{TypeScript}{Observable} stream in a sandboxed environment.

\subsection{Comparison}

Specialized utilities are aware of RP runtime environments and help software engineers to interpret its state better than before using sole traditional debugger tools. Most of them provide a way to represent the data flow graph either graphically (Reactive Inspector, rxfiddle) or in textual form (rxjs-spy). They visualize the data flowing through the graph over time in marble diagrams (rxfiddle, Rx Visualizer) or directly in the visual graph representation (Reactive Inspector). Some like Reactive Inspector for REScala provide an ``all in one'' solution with breakpoints, omniscient debugging capabilities and full IDE integration whereas the RxJS-based tools have a more specific feature set: They usually work outside of an IDE and/or need manual code instrumentation like rxjs-spy.

\textbf{TODO Compare im Table?}


\section{Study Design}
\label{sec:study}

\begin{itemize}
	\item Hypothesis
	\item Use prev section to build experiments using existing tooling
	\item Validate stories and interviews
\end{itemize}

\section{Future Work}
\label{sec:future}

\begin{itemize}
	\item Pick up results from war stories and experiment
	\item Propose one solution per challenges
	\item Sketch how this could look like
	\item This answers RQ2
\end{itemize}

\section{Threats to Validity}
\label{sec:threats}

\begin{itemize}
	\item Informal interviews/war stories only
	\begin{itemize}
		\item Describe background of interview partners
		\item Only 4 Participants in experiment
		\item Code in experiment carefully crafted... Though is it representative?
		\
	\end{itemize}
\end{itemize}

\section{Conclusion}
\label{sec:conclusion}

\begin{itemize}
	\item Recap Past Developments in RP Debugging
	\item Recap proposed solution
	\item Whats next in PA2?
	\item Whats the vision for the thesis?
\end{itemize}


\section{Appendix}

\subsection{Interview Questions}
\label{sec:interviewquestions}

\begin{itemize}
	\item When did you last apply RP?
	\item What technology did you use RP with?
	\item What was the best experience you had with RP?
	\item \dots and what was the worst? \dots Can you elaborate on the concrete situation?
\end{itemize}

\bibliographystyle{splncs04}
\bibliography{bibliography.bib}

\section*{License}
\ccby\thinspace\thinspace This work is licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.
\end{document}