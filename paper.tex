\documentclass[12pt,a4paper]{article}
\usepackage{ccicons}
\usepackage{hyperref}
\usepackage{minted}

\setminted{autogobble=true, tabsize=2, linenos=true, frame=single, breaklines=true}

\newcommand{\version}{v0.4 Draft}

\begin{document}
\begin{centering}

	\Large{Workshop Paper}
	\par
	\Huge{Debugging of RxJS-based Frontend Web Applications}
	\par
	\vspace{2ex}

	\normalsize{
		Manuel Alabor\\
		Supervised by Prof. Dr. Markus Stolze\\
		\par
		\vspace{2ex}
		HSR University of Applied Sciences Rapperswil\\
		\par
		\vspace{2ex}
		\today{} (\version)
	}
	\par
	\vspace{2ex}

	\begin{quotation}
		\small{
			\noindent\textbf{Abstract}---\input{./abstract.tex}
		}
		\par
		\vspace{4ex}
	\end{quotation}
\end{centering}

\section{Introduction}

An application providing a user interface (\emph{UI}) can be seen as a reactive application (\emph{RA})\cite{7827078}: It handles a continuos flow of user- and system-created events in order to give the user a representation of the applications state in a timely fashion. One way of implementing reactive behavior is the Observer design pattern\cite{gamma1995design} where an observer (e.g. the UI rendering code) is repeatedly informed about changed application state. With Reactive Programming (\emph{RP}), another way to implement RAs is trending. RP is enabled by language extensions, runtime environments and domain specific languages (\emph{DSL}) and based on functional programming (\emph{FP}) principles. With RP, software engineers describe declaratively how data flows through a RA, how that data depends from each other and how it is to be transformed over time.

Utilities to debug the runtime behavior of a program are essential to software engineers today. They help to understand the inner workings of unknown source code or allow to track down a problem which may lead to an unexpected failure in a particular situation. Debugging utilities took different forms over time: From interpreting memory dumps, manually adding print statements to trace program execution up to the point where specialized debugging programs can interrupt a running process and interact with it on a low level, software engineers have access to versatile debugging tools at present day.

Debuggers available in IDEs and the developer tools of a web browser\footnote{\url{https://developer.mozilla.org/en-US/docs/Tools/Debugger}} today are specialized to work with imperative, control-flow oriented programs. E.g. when an engineer wants to know which part of the program called a particular function, the stack trace gives a clear answer to this question. Assuming a data-flow oriented program implemented using RP, the question, which transformation was executed right before another cannot be answered using a stack trace: A breakpoint within the transformation will not point to its logical predecessor, it will lead to the internals of the RP runtime instead.

This lack specific knowledge about RP concepts in traditional debugging utilities does often end in time consuming debugging sessions as we can confirm from our own experience. Previous research has looked into this field \cite{10.1145/2577080.2577083} \cite{10.1145/2884781.2884815} \cite{10.1145/3180155.3180156} over the past years already. We will revisit their results in this paper and elaborate on the particular challenges of debugging RAs using RxJS for frontend web applications. On the way, we will answer following two research questions:

\begin{itemize}
	\item \emph{RQ1: What challenges do frontend engineers face when debugging RxJS-based code?}
	\item \emph{RQ2: How can the experience of frontend engineers during debugging of RxJS-based code be improved?}
\end{itemize}

Transcripts of informal interviews and ``war stories'' collected from multiple practitioners will give insight in the challenges they face in their day-to-day jobs. We will evaluate and validate three cases extracted from their statements in order to answer \emph{RQ1}.

In response to this, we will present three solution concepts for \emph{RQ2} to resolve previously identified problems which we expect to improve the debugging experience for RxJS-based code.

The future implementation and validation of these proposals leads to a third research question \emph{RQ3} which will be part of future work not part of this paper:

\begin{itemize}
	\item \emph{RQ3: What is the impact of a proposed solution on the debugging experience of a frontend engineer?}
\end{itemize}

We will conclude this introductory section with the clarification of important terms. Section~\ref{sec:interviews} presents the interview results along with the collected war stories and formalizes two recurrent challenges. With Section~\ref{sec:discussion}, we will have a look at current and previous research regarding debugging of reactive applications as well as specific tooling. We are going to validate presented challenges against currently available tools within Section~\ref{sec:study}, show threats to validity of our work in Section~\ref{sec:threats} and finally end with an outlook on future iterations.

\subsection{Reactive Applications}

Salvaneschi et al. \cite{7827078} define a RA as a computer program which processes a continuos, indefinite and ever-changing flow of data. Think of a spreadsheet application\cite{10.1145/2501654.2501666} that links the values of cells to other cells using formulas. Once a cell is changed, it is the task of the application to update all dependant cells accordingly and cascade the updates throughout the model. This data-flow based type of application is contrasted by program-flow based applications which consume and process one piece of input while producing a one-off output like an image format conversion program that transforms between HEIF\footnote{\url{https://nokiatech.github.io/heif/technical.html}} and JPEG image formats.

The classification schema by Salvaneschi et al. \cite{7827078} divides RAs into three types: A (i) \emph{synthetic application} transforms and processes streams of information. RAs are prevalent in the area of UIs further: They can be identified as (ii) \emph{interactive applications} and help to describe and implement (iii) \emph{graphical animations}.

\subsection{Reactive Programming}

Various ways of implementing RAs emerged over time. The Observer design pattern \cite{gamma1995design}, originated in Object Oriented Programming \emph{(OOP)}, is a pattern we can find in many of todays API implementations\cite{alabor:2019:reactiveappllications} allowing reactive behavior. Functional Programming \emph{(FP)} shines with specific reactive language extensions like Fran (Haskell) \cite{10.1145/2501654.2501666} or more recently REScala (Scala) \cite{10.1145/2577080.2577083}.

Reactive programming \emph{(RP)} is a declarative programming paradigm. Where engineers use imperative programing languages to tell a program every step \emph{how} to do something, a declarative language allows to describe \emph{what} wants to be achieved. The languages runtime system then figures out a way to satisfy that given description. RP environments specifically provide abstractions to describe a data-flow and dependency graph which is used to transform and direct data at runtime.

An RP environment provides (i) language constructs to describe mentioned graphs, often in form of a DSL\cite{10.1145/2577080.2577083}. At program runtime, a (ii) runtime system takes care that changed values are propagated through the graph, transformations are recomputed where necessary and a consistent application state is maintained.

\subsection{Debugging Concepts}

We divide debugging concepts roughly into three categories: Traditional \textbf{imperative-focused debuggers} provide basic functionality to interact with programs at runtime: Once code execution is paused (i.e. using a breakpoint at a given statement), we gain access to the current call stack and the values assigned to variables of a given frame. Manual control of the program execution allows to inspect its behavior step by step as well as assigning new values to variables ``on-the-fly''.

Where individual transformations of an RP based program can be inspected using traditional debuggers, they fall short in understanding the underlying model of the data-flow graph. In fact, RP provides its own challenges to debuggers: Call stacks expose internal invocations of the RP runtime system rather than e.g. the predecessor transformation according to the data-flow graph. Further, breakpoints can only be used on the imperative parts of transformations and lack the functionality of interrupting execution when the RP runtime hits a specific node within the graph. A \textbf{reactive debugger} has knowledge about the internal model of a RP runtime system. It leverages on it and provides specialized tools e.g. to navigate or visualize the data-flow graph \cite{10.1145/2884781.2884815} \cite{10.1145/3180155.3180156} \cite{rxviz}. We will have a closer look to available reactive debugger solutions.

The traditional as well as the reactive debugger works with the \emph{current} state of a programs execution only. They lack knowledge about what happened before or what is going to happen in the future. This shortcoming is tedious, especially when debugging a problem depending from multiple complex circumstances in a system. An \textbf{omniscient debugger} \cite{5287015} \cite{DBLP:journals/corr/OCallahanJFHNP17} does not interact with the executed program directly. Instead, it records runtime telemetry and provides an interface for later inspection. Engineers can ``time travel'' back and forth through the program execution trace without the hassle of reconstructing a given failure situation over and over again. This concept comes with its own set of challenges though: Once decided \emph{what} information should be recorded (everything, only specific parts of the program, one thread, multiple threads, \dots), demands on storage performance and capacity increase while the pool of collected data grows. As a result, user experience (\emph{UX}) concepts need to be aligned for the engineers being able to interact with the sheer amount\cite{5287015} of information efficiently.

\subsection{ReactiveX and RxJS}

``Reactive Extensions'' (\emph{ReactiveX}) is an open source project. Its members and contributors defined a generic description of an RP API. They further provide reference implementations of this API along with RP runtime environments for various programming languages like Java, C\# and JavaScript\footnote{\url{http://reactivex.io/languages.html}}. ReactiveX summarizes the API as ``\dots a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming''\cite{reactivex}. The core concept of the API specification is the \mintinline{TypeScript}{Observable}\footnote{There is no known relation between ReactiveX' concept of the \mintinline{TypeScript}{Observable} and the deprecated Java class \href{https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Observable.html}{\mintinline{TypeScript}{java.util.Observable}}.}: An \mintinline{TypeScript}{Observable} can be composed and linked (``piped'') with other \mintinline{TypeScript}{Observable}s. It has the ability to push (``emit'') values to its dependents. Multiple depending \mintinline{TypeScript}{Observable}s form and describe a data-flow graph eventually. A multitude of operators allow the transformation of values and (higher-order) \mintinline{TypeScript}{Observable}s. Values emitted from an \mintinline{TypeScript}{Observable} can be subscribed to at any point which is closely related to the Observer design patterns \mintinline{Java}{attach} method.

RxJS is the reference implementation of the ReactiveX API specification for JavaScript and TypeScript. It is used thoroughly by large projects like Angular\cite{angualrrxjs}. Listing \ref{lst:rp-with-rxjs} shows a simple example of RP using RxJS in TypeScript.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		import { of } from 'rxjs';
		import { filter, map } from 'rxjs/operators';

		of('hello', 'foo', 'world').pipe(  // Create Observable
			filter(s => s !== 'foo'),        // filter Operator
			map(s => s.toUpperCase())        // map Operator
		).subscribe(console.log)           // Emits: HELLO, WORLD
	\end{minted}
	\caption{Simple RxJS Example}
	\label{lst:rp-with-rxjs}
\end{listing}

\section{Interviews and War Stories}
\label{sec:interviews}

We have worked together with 15 professional software engineers during the process of answering RQ1. On the way of finding our interview partners and war stories reporters, we noticed it to be a challenge on its own to find people which understand themselves as users of RP and related technologies. E.g. even though Angular makes heavy use of RxJS, we will see that many engineers do not interact with its abstractions directly in order to build simple UIs. In the end we were able to gather interesting statements nonetheless which we are going to present in the upcoming section.

\subsection{Informal Interviews}

We organized informal interviews which allowed us to gain first insights in how software engineers work with RP in their daily jobs. We talked to six engineers and asked them about the technologies they use, what their personal experience with RP was, what they most liked and most disliked about it.

Four of our interview partners stated to currently work or more recently have worked with RxJS in conjunction with Angular and/or ngrx\footnote{\url{https://ngrx.io/}} to develop frontend web applications. By being the creator of a visualizer for RxJS \mintinline{TypeScript}{Observable}s, the fifth interviewee was a proficient RxJS user. Our sixth interview partner finally was a backend engineer which used akka-streams\footnote{\url{https://akka.io/}} in Scala to model data-flows for a WebSocket-based\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API}}, reactive API layer serving a web frontend application.

All of the interviewees referred to RP with an overall positive experience. We heard statements like ``RP is a good way for composing multiple data sources'' and ``having a statically typed language combined with RP already guarantees some kind of basic correctness of my program'' repeatedly throughout all sessions. Hence a big strength of RP seems to be the ability to describe complex data-flow constructs using a specialized DSL. The learning curve can be steep for a novice engineer though: ``Being already challenged with new concepts of Angular and ngrx, I noticed RxJS concepts and operators to be hard to grasp in addition on top'' an interview partner giving lectures in frontend web application development stated further.

It was interesting to hear that, especially in the area of developing web applications using Angular, our partners seemed not to have to work with pure RxJS code often. E.g. when using ngrx for state management, ``the framework takes care that you do not have to interact with Observables on your own, but leverages greatly on their potential behind the scenes''. As soon as our interviewees had to extend built-in functionalities with their own features, e.g. a new effect\footnote{\url{https://ngrx.io/guide/effects}}, all of them valued the possibility to interact with underlying \mintinline{TypeScript}{Observable}s highly.

When asked explicitly about what they dislike the most about RP, all interview partners with no exception emphasized the debugging process of an RP application as a big nuisance. The fact that our interviewees remembered the search for a bug as something negative did not surprise us, hence a bug is usually something negative afflicted. What did alarm us though was the fact that statements like ``In 99\% of all cases, I add console.log statements manually and run the program over and over again, trying to understand what is happening'' were prevalent and gave insight in \emph{why} our interview partners dislike RP debugging in particular. Multiple interviewees mentioned the Redux DevTools\footnote{\url{https://chrome.google.com/webstore/detail/redux-devtools}} as helpful when debugging Angular/ngrx applications nonetheless. Further, one single partner mentioned marble diagrams as very valuable in order to understand how an RxJS \mintinline{TypeScript}{Observable} works, no matter if during development or when debugging code. Marble diagrams are a way to visualize and describe the value-emitting behavior of an \mintinline{TypeScript}{Observable} over time. They are accepted throughout the ReactiveX community for documentation\cite{marblediagrams} and testing reasons\cite{marbletesting}.


\subsection{War Stories}

Based on the results of the interviews, we compiled a request for more specific factual reports. We asked professional software engineers about their most recent debugging experience in regards of RxJS, either good or bad. We were able to gather responses from one RxJS core team member, two Google Developer Experts and two engineers building web and mobile applications for a fintech company eventually.

We could verify previously gathered interview data with the results from the new reports: The subjects tend to manually add log statements to their code in order to understand its behavior, especially when things get more complex. Three subjects even claimed using specialized logging functionalities provided by rxjs-spy\cite{rxjsspy}. As the subjects stated, the knowledge about additional events made visible helped in situations where they needed to find problems within a graph composing multiple asynchronous data sources on multiple levels. Without it, they would have been blind to what actually happened within the system.

In addition to more sophisticated logging, three subjects reported that they built a habit of decomposing complex graphs into smaller, simpler bits and running those in a dedicated environment like Rx Visualizer\cite{rxviz} or StackBlitz\footnote{\url{https://stackblitz.com/}}.

\subsection{Summary}

The interpretation of the combined interview and war stories data gives us an idea about two main challenges software engineers have to overcome during debugging activities of RxJS-based code:

It is crucial to the engineers to \textbf{understand data flows}  within the \mintinline{TypeScript}{Observable} graph. Questions like ``Which source emitted a value at what time?'' or ``What is the result of a specific transformation?'' are common in this context. Once a program fails, software engineers need to \textbf{rely on traditional debugger tools}. Though providing help to some extent, the tools lack of specific knowledge about the RP runtime environment adds some oddities to the debugging process: The (i) functionalities allowing step-wise navigation through the code does not respect the RP context. Assume we have set a breakpoint at \mintinline{TypeScript}{i * 2} on line~2 of Listing~\ref{lst:rxjs-step-controls}. Once the debugger hits the breakpoint and we instruct it to ``Step Over'', the debugger will lead us to the internal implementation of the \mintinline{TypeScript}{map} operator instead to line~3. (ii) Stack traces include information about the invocation of internal functions which, most of the time, do not provide any valuable information to the engineers further.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		interval(1000).pipe(      // Increasing numbers with 1s delay
		  map(i => i * 2),        // Breakpoint on i * 2
		  map(i => i - 1),
		  take(2)
		).subscribe(console.log); // -1, 1
	\end{minted}
	\caption{Example RxJS Stream With Breakpoint on Line 2 Within the Arrow Function}
	\label{lst:rxjs-step-controls}
\end{listing}


\section{Discussion of Previous Efforts}
\label{sec:discussion}

Our work is not the first approach on understanding and improving on the struggles software engineers have to overcome when working on RP code, either with or without RxJS. We are going to present four of this tools in this section. This list is not meant to be exhaustive. It contains tools we either got to know during our research because they were mentioned in one of the interviews or we worked with them personally in the past.

\subsection{Reactive Inspector}

Salvaneschi et al. did focus their research heavily on RP during the mid 2010s. Beside the creation of REScala in 2014 \cite{10.1145/2577080.2577083}, an RP DSL and runtime for the Scala programming language, they looked into the debugging habits of software engineers as well. In the paper ``Debugging for Reactive Programming'' \cite{10.1145/2884781.2884815}, Salvaneschi et al. elaborate on the necessity of RP debugging tools which can understand the specific language abstractions. With the plugin Reactive Inspector for the Eclipse IDE, they provide a debugger which understands the RP language abstractions of REScala. One of its main features is the visualization of the internal dependency graph. The new class of  breakpoints, the ``reactive breakpoints'', builds upon the visualized graph as well: They do not depend on a specific line of code or statement rather then on a specific node in the graph. The execution of the program can be interrupted e.g. once a node retains a specific output value or an event of interest takes place in the runtime. Along with the RP specific debugging features, Reactive Inspector implements omniscient debugging concepts as well: Time travel allows to record and replay runtime behavior at a later time without reexecution.

Salvaneschi et al. claim\cite{10.1145/2577080.2577083} the architecture behind \emph{Reactive Inspector} to be flexible enough to be used with different RP runtime environment as well.

\subsection{rxfiddle}

rxfiddle proposed by Banken et al. is the first reference implementation of their RP debugger architecture for the ReactiveX API specification described in their paper ``Debugging Data Flows in Reactive Programs'' \cite{10.1145/3180155.3180156}. The design defines two independent parts: The (i) \emph{Host instrumentation} instruments a ReactiveX implementation to emit events at runtime (e.g. when an \mintinline{TypeScript}{Observable} is created or subscribed) which get collected. The (ii) \emph{Visualizer} component interprets these events and presents them along two dimensions: The StoryFlow graph \cite{YWu2013a} shows when an \mintinline{TypeScript}{Observable} is created and how it interacts with other \mintinline{TypeScript}{Observable}s. An additional marble diagram for every \mintinline{TypeScript}{Observable} is used to display the values it emits over time.

The reference implementation supports event collection for RxJS-based code in version 4 and 5. It can either be used on a local development machine on existing projects or by copying code snippets to the online available.

The architectural design of \emph{rxfiddle} is similar to the one \emph{Reactive Inspector}: Banken et al. provide a system where different RP runtime environments should be able to be attached to the Visualizer easily.


\subsection{rxjs-spy}

Software engineers tend to augment their code with additional log trace statements in the situation where they have to track down a problem as we saw earlier. rxjs-spy\cite{rxjsspy} intends to improve on this by introducing the \mintinline{TypeScript}{tag} operator. Instead of adding log traces at debug-time, ``tagged'' \mintinline{TypeScript}{Observable}s are created right at the moment the \mintinline{TypeScript}{Observable} itself is defined. A tag as shown in Listing~\ref{lst:rxjs-spy-tag} does not influence runtime behavior at first.

\begin{listing}[H]
	\begin{minted}{TypeScript}
		interval(1000).pipe(
		  map(i => i * 2),
		  tag('multiply'),
		  map(i => i - 1),
		  take(2)
		).subscribe();
	\end{minted}
	\caption{Usage of \emph{rxjs-spy} \mintinline{TypeScript}{tag} Operator on Line 3}
	\label{lst:rxjs-spy-tag}
\end{listing}

Later, rxjs-spy can be advised to log events such as subscribe, emit, error, complete and unsubscribe of matching tags directly to the console without touching any \mintinline{TypeScript}{Observable} code at all. It is worth to mention that manual log traces, without additional effort, only show values flowing by. The additional events logged by rxjs-spy were noted invaluable in the interviews presented earlier as well as in our own experience.

\begin{listing}[H]
	\begin{minted}{Typescript}
		Tag = multiply; notification = subscribe
		Tag = multiply; notification = next; value = 0
		Tag = multiply; notification = next; value = 2
		Tag = multiply; notification = unsubscribe
	\end{minted}
	\caption{Trace log generated by \emph{rxjs-spy} \mintinline{TypeScript}{tag} from Listing~\ref{lst:rxjs-spy-tag}}
	\label{lst:rxjs-spy-log}
\end{listing}

Additional features are available through the debuggers console interface. A tagged \mintinline{TypeScript}{Observable} can be paused so it collects incoming values. They can then be emitted one after another or resumed at once.

\subsection{Rx Visualizer}

The \emph{Rx Visualizer}\cite{rxviz} is a utility available online in the browser. It is an ``animated playground for Rx Observables''\cite{rxviz} and allows to visualize snippets of RxJS code using marble diagrams. Diagrams are generated over a given, fixed time and can be saved as SVG\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/SVG}}.

The visualizer helps to understand the behavior of a specific part of an \mintinline{TypeScript}{Observable} stream in a sandboxed environment.

\subsection{Comparison}

Specialized utilities are aware of RP runtime environments and help software engineers to interpret its state better than before using sole traditional debugger tools. Most of them provide a way to represent the data flow graph either graphically (Reactive Inspector, rxfiddle) or in textual form (rxjs-spy). They visualize the data flowing through the graph over time in marble diagrams (rxfiddle, Rx Visualizer) or directly in the visual graph representation (Reactive Inspector). Some like Reactive Inspector for REScala provide an ``all in one'' solution with breakpoints, omniscient debugging capabilities and full IDE integration whereas the RxJS-based tools have a more specific feature set: They usually work outside of an IDE and/or need manual code instrumentation like rxjs-spy.

\textbf{TODO Compare im Table?}


\section{Study Design}
\label{sec:study}

\begin{itemize}
	\item Hypothesis
	\item Use prev section to build experiments using existing tooling
	\item Validate stories and interviews
\end{itemize}

\section{Future Work}
\label{sec:future}

\begin{itemize}
	\item Pick up results from war stories and experiment
	\item Propose one solution per challenges
	\item Sketch how this could look like
	\item This answers RQ2
\end{itemize}

\section{Threats to Validity}
\label{sec:threats}

\begin{itemize}
	\item Informal interviews/war stories only
	\begin{itemize}
		\item Describe background of interview partners
		\item Only 4 Participants in experiment
		\item Code in experiment carefully crafted... Though is it representative?
		\
	\end{itemize}
\end{itemize}

\section{Conclusion}
\label{sec:conclusion}

\begin{itemize}
	\item Recap Past Developments in RP Debugging
	\item Recap proposed solution
	\item Whats next in PA2?
	\item Whats the vision for the thesis?
\end{itemize}


\bibliographystyle{splncs04}
\bibliography{bibliography.bib}

\section*{License}
\ccby\thinspace\thinspace This work is licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.
\end{document}